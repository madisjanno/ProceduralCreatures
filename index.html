<!DOCTYPE>
<html>
	<head>
		<title>Prototype</title>
		<script type="text/javascript" src="three.r87.js"></script>
        <script type="text/javascript" src="bundle.js"></script>
        <script type="text/javascript" src="http://rawgit.com/mrdoob/stats.js/master/build/stats.min.js"></script>
		<script type="text/javascript">
		
			var renderer, scene, camera;
			var lookAt = new THREE.Vector3(0.0, 0.0, 0.0);
			var viewerPosition = new THREE.Vector3(0.0, 0.0, 30.0);
            
            var skeleton;
            var metaballs;
            var polygon;
            
            var lines;
            var triangles;
            var skeletonhelper;
            var texture;
            
            var woodTexture = new THREE.TextureLoader().load( 'wood.jpeg' );
            var iceTexture = new THREE.TextureLoader().load( 'ice.jpeg' );
            
            var interval = 5;
            var smoothInterpolation = true;
            var wireframe = false;
            var paused = false;
            
            var clock = new THREE.Clock();
            
			var stats = new Stats();
			stats.showPanel( 1 ); // 0: fps, 1: ms, 2: mb, 3+: custom
			
			function millis() {

				return (new Date()).getTime();
			}
			
			function toRad(degree) {
			
				return Math.PI * 2 * degree / 360;
			}
		
			function onLoad() { 
				var canvasContainer = document.getElementById('myCanvasContainer');
                document.body.appendChild( stats.dom );
				var width = 800; 
				var height = 500;
				
				renderer = new THREE.WebGLRenderer(); 
				renderer.setSize(width, height);
				canvasContainer.appendChild(renderer.domElement);
				
				scene = new THREE.Scene();
                
				camera = new THREE.OrthographicCamera( width / - 2, width / 2, height / 2, height / - 2, 1, 1000 );
				camera.position.set(viewerPosition.x, viewerPosition.y, viewerPosition.z);
				camera.up = new THREE.Vector3(0, 1, 0);
				camera.lookAt(lookAt);
				
				vertexShader = document.getElementById('vertexShader').textContent;
				fragmentShader = document.getElementById('fragmentShader').textContent;
                
                //--------------------------
                    console.log("generating skeleton");
                    skeleton = generateSkeleton();
                    
                    console.log("generating metaballs");
                    metaballs = [];
                    generateMetaballs(metaballs, skeleton.bones[0]);
                    
                    
                    console.log("generating polygon");
                    polygon = generatePolygon(metaballs);
                    
                    
                    lines = new THREE.Line( new THREE.Geometry, new THREE.LineBasicMaterial({color: 0xff00ff00}) );
                    lines.geometry.vertices = polygon;
                    lines.geometry.verticesNeedUpdate = true;
                    lines.position.z += 1;
                    
                    //scene.add(lines);
                    
                    console.log("generating texture");
                    var lowestX = polygon[0].x, lowestY = polygon[0].y, highestX = polygon[0].x, highestY = polygon[0].y;
                    for (var i = 0; i < polygon.length; i++) {
                        lowestX = Math.min(lowestX, polygon[i].x)
                        lowestY = Math.min(lowestY, polygon[i].y)
                        highestX = Math.max(highestX, polygon[i].x)
                        highestY = Math.max(highestY, polygon[i].y)
                    }
                    
                    texture = generateTexture(metaballs, [lowestX, lowestY, highestX-lowestX, highestY-lowestY]);
                    
                    console.log("generating mesh");
                    triangles = generateMesh(texture, polygon, metaballs, skeleton);
                    skeletonhelper = new THREE.SkeletonHelper( triangles );
                
                    triangles.position.y = -200;
                    
                    scene.add(triangles);
                    //scene.add(skeletonhelper);
                
                    dataContainer.children[1].innerHTML = polygon.length.toString();
                    dataContainer.children[4].innerHTML = triangles.geometry.faces.length.toString();
                    
                    
                //--------------------------
                
                // DEBUG DISPLAY
                fragmentShader = fragmentShader.replace("METABALL_COUNT", metaballs.length).replace("METABALL_COUNT", metaballs.length);
                console.log(fragmentShader);
                
                var geometry = new THREE.PlaneBufferGeometry( 500, 500 );
                var material = new THREE.ShaderMaterial({
					uniforms: {
                        metaballs: new THREE.Uniform(metaballs)
                    },
					vertexShader: vertexShader,
					fragmentShader: fragmentShader,
                    side: THREE.DoubleSide
				});
                var plane = new THREE.Mesh( geometry, material );
                plane.position.z = -1;
                //scene.add( plane );
                
                var geometry = new THREE.PlaneBufferGeometry( 256, 256 );
                var material = new THREE.MeshBasicMaterial({map: texture});
                var plane = new THREE.Mesh( geometry, material );
                plane.position.x -= 400-128;
                plane.position.y += 250-128;
                //scene.add( plane );
                
				draw();
				
                
				window.addEventListener('keydown', function(event) {
					if (event.keyCode == 38) { //Up
						smoothInterpolation = true;
                        interpolationStatusContainer.children[1].innerHTML = smoothInterpolation.toString();
					}
					if (event.keyCode == 40) { //Down
						smoothInterpolation = false;
                        interpolationStatusContainer.children[1].innerHTML = smoothInterpolation.toString();
					}
					if (event.keyCode == 37) { //Right
						interval--;
                        if (interval < 1)
                            interval = 1;
                        gridStatusContainer.children[1].innerHTML = interval.toString();
					}
					if (event.keyCode == 39) { //Left
                        interval++;
                        gridStatusContainer.children[1].innerHTML = interval.toString();
					}
					if (event.keyCode == 87) { //W
                        wireframe = !wireframe;
                        triangles.material.wireframe = wireframe;
                        wireframeStatusContainer.children[1].innerHTML = wireframe.toString();
					}
                    if (event.keyCode == 32) { //Space
                        console.log(lines.geometry.vertices)
                        paused = !paused;
					}
				}, false);
                
			}
			
			function draw() {
				requestAnimationFrame(draw);
                
                stats.begin();
				
                var dt = clock.getDelta();
                
                if (!paused) {
                    
                    for (var i = 0; i < skeleton.bones.length; i++) {
                        skeleton.bones[i].rotation.z = Math.sin(clock.getElapsedTime()*(i/0.23+1)/10.0);
                    }
                    
                }
                
				renderer.render(scene, camera);
                
                stats.end();
			}
            
            function generateSkeleton() {

                /*
                bone = new THREE.Bone();
                    bone.thickness = 20;
                
                var b2 = new THREE.Bone();
                    b2.thickness = 20;
                    bone.add(b2);
                    b2.position.x = 40;
                    b2.color = new THREE.Vector3(1.0, 0.0, 0.0);
                
                var b3 = new THREE.Bone();
                    b3.thickness = 20;
                    b2.add(b3);
                    b3.position.x = 40;
                    b3.color = new THREE.Vector3(0.0, 1.0, 0.0);
                    b3.texture_weights = new THREE.Vector4(0.0, 1.0, 0.0, 0.0);
                
                var b4 = new THREE.Bone();
                    b4.thickness = 20;
                    b3.add(b4);
                    b4.position.x = 40;
                    b4.color = new THREE.Vector3(0.0, 0.0, 1.0);
                
                var b5 = new THREE.Bone();
                    b5.thickness = 20;
                    b4.add(b5);
                    b5.position.x = 40;
                
                var b6 = new THREE.Bone();
                    b6.thickness = 20;
                    b5.add(b6);
                    b6.position.x = 40;
                    b6.texture_weights = new THREE.Vector4(0.0, 1.0, 0.0, 0.0);
                
                var skeleton = new THREE.Skeleton([bone, b2, b3, b4, b5]);
                return skeleton;
                */
                
                var spineSegments = Math.round(2+Math.random()*7);
                
                var skeleton = [];
                var spine = [];
                var rootBone = new THREE.Bone();
                spine.push(rootBone);
                
                for (var i = 1; i < spineSegments; i++) {
                    var spineSegment = new THREE.Bone();
                    
                    spineSegment.thickness = 10+Math.random()*20;
                    spineSegment.position.y = 50+Math.random()*50;
                    var a = Math.random();
                    spineSegment.texture_weights = new THREE.Vector4(a, 1.0-a, 0.0, 0.0);
                    spineSegment.color = new THREE.Vector3(Math.random(), Math.random(), Math.random());
                    
                    spine[i-1].add(spineSegment);
                    spine.push(spineSegment);
                }
                skeleton.push(...spine);
                
                
                for (var i = 0; i < spineSegments; i++) {
                    if (Math.random() > 0.5) {
                        var limbSegments = Math.round(2+Math.random()*7);
                        
                        var limbSegmentLengths = [];
                        var limbSegmentThicknesses = [];
                        
                        for (var j = 0; j < limbSegments; j++) {
                            limbSegmentLengths.push(20+Math.random()*10);
                            limbSegmentThicknesses.push(5+Math.random()*15);
                        }
                        limbSegmentThicknesses[0] = 5;
                        
                        for (var dir = -1; dir < 2; dir+=2) {
                            var limb = [];
                            
                            var limbJoint = new THREE.Bone();
                            if (i > 0)
                                limbJoint.position.x = dir*spine[i].thickness;
                            else
                                limbJoint.position.x = dir*spine[i+1].thickness;
                            limbJoint.thickness = limbSegmentThicknesses[0];
                            limb.push(limbJoint);
                            spine[i].add(limbJoint);
                            
                            for (var j = 1; j < limbSegments; j++) {
                                var limbSegment = new THREE.Bone();

                                limbSegment.thickness = limbSegmentThicknesses[j];
                                limbSegment.position.x = dir*limbSegmentLengths[j];
                                limbSegment.color = new THREE.Vector3(Math.random(), Math.random(), Math.random());

                                limb[j-1].add(limbSegment);
                                limb.push(limbSegment);
                            }
                            
                            skeleton.push(...limb);
                        }
                        
                    }
                }
                
                
                
                console.log(skeleton);
                return new THREE.Skeleton(skeleton);
            }
            
            function generateMetaballs(metaballs, bone, parent) {
                if (parent !== undefined) {
                    
                    var boneLocation = bone.getWorldPosition();
                    var parentLocation = parent.getWorldPosition();
                    
                    var subballs = 5;
                    boneLocation.z = bone.thickness / Math.sqrt(subballs);
                    parentLocation.z = bone.thickness / Math.sqrt(subballs);
                    
                    //subballs = Math.ceil(boneLocation.distanceTo(parentLocation)/(bone.thickness*2));
                    //boneLocation.z = bone.thickness;
                    //parentLocation.z = bone.thickness;
                    
                    for (var i = 1; i <= subballs; i++) {
                        var alpha = i/subballs;
                        var ball = boneLocation.clone().lerp(parentLocation, alpha);
                        ball.boneID = skeleton.bones.indexOf(parent);
                        
                        if (bone.color) {
                            if (parent.color) {
                                ball.color = bone.color.clone().lerp(parent.color, alpha);
                            } else {
                                ball.color = bone.color;
                            }
                        }
                        if (bone.texture_weights) {
                            ball.texture_weights = bone.texture_weights;
                        }
                        
                        metaballs.push(ball);
                    }
                    
                    //metaballs.push(boneLocation);
                }
                
                bone.children.forEach(function(child) {
                    generateMetaballs(metaballs, child, bone);
                });
            }
            
            const UP = 0;
            const DOWN = 1;
            const LEFT = 2;
            const RIGHT = 3;
            
            function generatePolygon(metaballs) {
                var start = metaballs[0];
                for (var i = 1; i < metaballs.length; i++) {
                    if (metaballs[i].y > start.y) {
                        start = metaballs[i];
                    }
                }
                start = start.clone();
                
                start.z = 0;
                
                var counter = 0;
                while (calculateValueAt(start, metaballs) >= 1.0) {
                    console.log("crawling in my skiiin", start, calculateValueAt(start, metaballs));
                    start.add(new THREE.Vector3(0.0, interval));
                    counter++;
                    if (counter > 100)
                        return;
                }
                console.log("crawling complete", start, calculateValueAt(start, metaballs));
                
                var topLeft, topRight, bottomLeft, bottomRight;
                /*
                var topLeft = start.clone();
                var topRight = topLeft.clone().add(new THREE.Vector3(interval, 0));
                var bottomLeft = topLeft.clone().add(new THREE.Vector3(0.0, -interval));
                var bottomRight = topLeft.clone().add(new THREE.Vector3(interval, -interval));
                */
                topRight = addValueTo(start.clone(), metaballs);
                bottomRight = addValueTo(start.clone().add(new THREE.Vector3(0.0, -interval)), metaballs);
                
                var prev = RIGHT;
                
                var vertices = [];

                passedStart = false;
                
                var x = -1;
                var y = 0;
                
                var counter = 0;
                while (counter < 20000) {
                    counter++;
                    if (prev == RIGHT) {x++;}
                    if (prev == LEFT) {x--;}
                    if (prev == UP) {y++;}
                    if (prev == DOWN) {y--}
                    
                    if (prev == RIGHT && x == 0 && y == 0) {
                        if (passedStart) {
                            break;
                        }
                        passedStart = true;
                    }
                    
                    if (prev == UP) {
                        bottomLeft = topLeft;
                        bottomRight = topRight;
                        topLeft = addValueTo(bottomLeft.clone().add(new THREE.Vector3(0.0, interval)), metaballs);
                        topRight = addValueTo(bottomRight.clone().add(new THREE.Vector3(0.0, interval)), metaballs);
                        
                        var tl = topLeft.value >= 1.0;
                        var tr = topRight.value >= 1.0;
                        var bl = bottomLeft.value >= 1.0;
                        var br = bottomRight.value >= 1.0;
                        
                        if (tl && tr) {
                            prev = LEFT;
                            vertices.push(interpolateLocation(topLeft, bottomLeft));
                            continue;
                        }
                        if (!tl && tr) {
                            prev = UP;
                            vertices.push(nextVertex(prev, topLeft, topRight, bottomLeft, bottomRight));
                            continue;
                        }
                        if (!tl && !tr) {
                            prev = RIGHT;
                            vertices.push(nextVertex(prev, topLeft, topRight, bottomLeft, bottomRight));
                            continue;
                        }
                        if (tl && !tr) {
                            var middle = addValueTo(topLeft.clone().add(bottomRight).divideScalar(2.0), metaballs);
                            if (middle.value >= 1.0) {
                                prev = LEFT;
                                vertices.push(nextVertex(prev, topLeft, topRight, bottomLeft, bottomRight));
                            } else {
                                prev = RIGHT;
                                vertices.push(nextVertex(prev, topLeft, topRight, bottomLeft, bottomRight));
                            }
                            continue;
                        }
                    }
                    
                    if (prev == DOWN) {
                        topLeft = bottomLeft;
                        topRight = bottomRight;
                        bottomLeft = addValueTo(topLeft.clone().add(new THREE.Vector3(0.0, -interval)), metaballs);
                        bottomRight = addValueTo(topLeft.clone().add(new THREE.Vector3(interval, -interval)), metaballs);
                        
                        var tl = topLeft.value >= 1.0;
                        var tr = topRight.value >= 1.0;
                        var bl = bottomLeft.value >= 1.0;
                        var br = bottomRight.value >= 1.0;
                        
                        if (bl && br) {
                            prev = RIGHT;
                            vertices.push(nextVertex(prev, topLeft, topRight, bottomLeft, bottomRight));
                            continue;
                        }
                        if (!bl && !br) {
                            prev = LEFT;
                            vertices.push(nextVertex(prev, topLeft, topRight, bottomLeft, bottomRight));
                            continue;
                        }
                        if (bl && !br) {
                            prev = DOWN;
                            vertices.push(nextVertex(prev, topLeft, topRight, bottomLeft, bottomRight));
                            continue;
                        }
                        if (!bl && br) {
                            var middle = addValueTo(topLeft.clone().add(bottomRight).divideScalar(2.0), metaballs);
                            if (middle.value >= 1.0) {
                                prev = RIGHT;
                                vertices.push(nextVertex(prev, topLeft, topRight, bottomLeft, bottomRight));
                            } else {
                                prev = LEFT;
                                vertices.push(nextVertex(prev, topLeft, topRight, bottomLeft, bottomRight));
                            }
                            continue;
                        }
                    }
                    
                    if (prev == LEFT) {
                        topRight = topLeft;
                        bottomRight = bottomLeft;
                        topLeft = addValueTo(topRight.clone().add(new THREE.Vector3(-interval, 0.0)), metaballs);
                        bottomLeft = addValueTo(bottomRight.clone().add(new THREE.Vector3(-interval, 0.0)), metaballs);
                        
                        var tl = topLeft.value >= 1.0;
                        var tr = topRight.value >= 1.0;
                        var bl = bottomLeft.value >= 1.0;
                        var br = bottomRight.value >= 1.0;
                        
                        if (tl && bl) {
                            prev = DOWN;
                            vertices.push(nextVertex(prev, topLeft, topRight, bottomLeft, bottomRight));
                            continue;
                        }
                        if (!tl && !bl) {
                            prev = UP;
                            vertices.push(nextVertex(prev, topLeft, topRight, bottomLeft, bottomRight));
                            continue;
                        }
                        if (tl && !bl) {
                            prev = LEFT;
                            vertices.push(nextVertex(prev, topLeft, topRight, bottomLeft, bottomRight));
                            continue;
                        }
                        if (!tl && bl) {
                            var middle = addValueTo(topLeft.clone().add(bottomRight).divideScalar(2.0), metaballs);
                            if (middle.value >= 1.0) {
                                prev = DOWN;
                                vertices.push(nextVertex(prev, topLeft, topRight, bottomLeft, bottomRight));
                            } else {
                                prev = UP;
                                vertices.push(nextVertex(prev, topLeft, topRight, bottomLeft, bottomRight));
                            }
                            continue;
                        }
                    }
                    
                    if (prev == RIGHT) {
                        topLeft = topRight;
                        bottomLeft = bottomRight;
                        topRight = addValueTo(topLeft.clone().add(new THREE.Vector3(interval, 0.0)), metaballs);
                        bottomRight = addValueTo(bottomLeft.clone().add(new THREE.Vector3(interval, 0.0)), metaballs);
                        
                        var tl = topLeft.value >= 1.0;
                        var tr = topRight.value >= 1.0;
                        var bl = bottomLeft.value >= 1.0;
                        var br = bottomRight.value >= 1.0;
                        
                        if (tr && br) {
                            prev = UP;
                            vertices.push(nextVertex(prev, topLeft, topRight, bottomLeft, bottomRight));
                            continue;
                        }
                        if (!tr && !br) {
                            prev = DOWN;
                            vertices.push(nextVertex(prev, topLeft, topRight, bottomLeft, bottomRight));
                            continue;
                        }
                        if (!tr && br) {
                            prev = RIGHT;
                            vertices.push(nextVertex(prev, topLeft, topRight, bottomLeft, bottomRight));
                            continue;
                        }
                        if (tr && !br) {
                            var middle = addValueTo(topLeft.clone().add(bottomRight).divideScalar(2.0), metaballs);
                            if (middle.value >= 1.0) {
                                prev = UP;
                                vertices.push(nextVertex(prev, topLeft, topRight, bottomLeft, bottomRight));
                            } else {
                                prev = DOWN;
                                vertices.push(nextVertex(prev, topLeft, topRight, bottomLeft, bottomRight));
                            }
                            continue;
                        }
                    }
                }
                
                return vertices;
            }
            
            function generateMesh(texture, polygon, metaballs, skeleton) {
                
                var triangles = new THREE.SkinnedMesh( new THREE.Geometry, new THREE.MeshBasicMaterial({color: 0xffffffff, wireframe: wireframe, skinning:true, map: texture}) );
                triangles.geometry.vertices = polygon.slice(0);

                // vertices
                var points = [];

                for (var i = 0; i < polygon.length; i++) {
                    points.push([polygon[i].x, polygon[i].y]);
                }
                
                /*
                for (var i = 0; i < Math.min(metaballs.length, 40); i++) {
                    if (i == 29 || i == 39)
                        continue;
                    metaball_loc = metaballs[i].clone();
                    metaball_loc.z = 0;
                    triangles.geometry.vertices.push(metaball_loc);
                    points.push([metaball_loc.x, metaball_loc.y])
                }
                */
                
                // area covered by mesh
                var lowestX = polygon[0].x, lowestY = polygon[0].y, highestX = polygon[0].x, highestY = polygon[0].y;
                for (var i = 0; i < polygon.length; i++) {
                    lowestX = Math.min(lowestX, polygon[i].x)
                    lowestY = Math.min(lowestY, polygon[i].y)
                    highestX = Math.max(highestX, polygon[i].x)
                    highestY = Math.max(highestY, polygon[i].y)
                }
                
                console.log(lowestX)
                
                // adds points in uniform grid to fill out interior
                var offset = highestY-lowestY;
                for (var x = lowestX+0.01; x < highestX+offset; x+=20.1711) {
                    for (var y = lowestY+0.01; y < highestY; y+=20.1711) {
                        var skew = (y-lowestY)/2;
                        triangles.geometry.vertices.push(new THREE.Vector3(x-skew, y, 0));
                        points.push([x-skew, y])
                    }
                }
                
                var edges = [];
                for (var i = 0; i < polygon.length; i++) {
                    var j = (i + 1) % polygon.length;
                    edges.push([i, j]);
                }
                
                // faces
                var faces = cdt2d(points, edges, {exterior: false});
                triangles.geometry.faceVertexUvs = [[]];
                
                width = highestX - lowestX;
                height = highestY - lowestY;
                function mapUV(vertexI) {
                    var vertex = triangles.geometry.vertices[vertexI];
                    return new THREE.Vector2( (vertex.x-lowestX)/width, (vertex.y-lowestY)/height );
                }
                
                for (var i = 0; i < faces.length; i++) {
                    triangles.geometry.faces.push( new THREE.Face3(faces[i][0],faces[i][1],faces[i][2]) );
                    triangles.geometry.faceVertexUvs[0].push([mapUV(faces[i][0]),mapUV(faces[i][1]),mapUV(faces[i][2])]);
                }
                
                console.log(triangles.geometry.faceVertexUvs)
                
                triangles.geometry.computeVertexNormals();
                
                // skinning
                triangles.add(skeleton.bones[0]);
                for (var i = 0; i < triangles.geometry.vertices.length; i++) {
                    var data = calculateSkinningData(triangles.geometry.vertices[i], metaballs, skeleton);
                    //console.log(data);
                    triangles.geometry.skinIndices.push( data[0] );
                    triangles.geometry.skinWeights.push( data[1] );
                    
                    triangles.geometry.vertices[i].z = (triangles.geometry.vertices[i].y-highestY)/height;
                }
                triangles.bind( skeleton );
                
                return triangles;
            }
            
            function nextVertex(dir, topLeft, topRight, bottomLeft, bottomRight) {
                if (dir == UP) {
                    return interpolateLocation(topLeft, topRight);
                }
                if (dir == DOWN) {
                    return interpolateLocation(bottomLeft, bottomRight);
                }
                if (dir == LEFT) {
                    return interpolateLocation(topLeft, bottomLeft);
                }
                if (dir == RIGHT) {
                    return interpolateLocation(topRight, bottomRight);
                }
            }
            
            function addValueTo(vec, metaballs) {
                vec.value = calculateValueAt(vec, metaballs);
                return vec;
            }
            
            function calculateMetaballValue(x, y, metaball) {
                var distance = Math.pow(metaball.x-x, 2.0)+Math.pow(metaball.y-y, 2.0);
                var blobbyness = -0.25;
                return 1.0*Math.exp(blobbyness*distance/(metaball.z*metaball.z)-blobbyness);
                
                //float distance = dot(metaballs[i].xy-vertexPosition.xy, metaballs[i].xy-vertexPosition.xy);
                //float blobbyness = -0.25;
                //dist += 1.0*exp(blobbyness*distance/(metaballs[i].z*metaballs[i].z)-blobbyness);
            }
            
            function calculateValueAt(c, metaballs) {
                var x = c.x;
                var y = c.y;
                var val = 0.0;
                for (var i = 0; i < metaballs.length; i++) {
                    var metaball = metaballs[i];
                    //addedVal = Math.pow(metaball.z, 2.0)/(Math.pow(metaball.x-x, 2.0)+Math.pow(metaball.y-y, 2.0));
                    var addedVal = calculateMetaballValue(x, y, metaball);
                    if (!isFinite(addedVal)) {
                        //console.log(addedVal);
                        addedVal = 10000.0;
                    }
                    val += addedVal;
                }
                return val;
            }
            
            function calculateSkinningData(v, metaballs, skeleton) {
                var x = v.x;
                var y = v.y;
                
                boneValues = []
                for (var i = 0; i < skeleton.bones.length; i++) [boneValues.push({id:i,value:0})]
                
                for (var i = 0; i < metaballs.length; i++) {
                    var metaball = metaballs[i];
                    //addedVal = Math.pow(Math.pow(metaball.z, 2.0)/distance, 2.0);
                    var addedVal = calculateMetaballValue(x, y, metaball);
                    if (!isFinite(addedVal))
                        addedVal = 10000.0;
                    
                    boneValues[metaball.boneID].value += addedVal;
                }
                
                boneValues.sort(function(a, b){return b.value - a.value});
                
                boneIndices = new THREE.Vector4( 
                        boneValues[0].id,
                        boneValues[1].id, 
                        boneValues[2].id, 
                        boneValues[3].id
                    );
                
                boneWeights = new THREE.Vector4( 
                        boneValues[0].value,
                        boneValues[1].value, 
                        boneValues[2].value, 
                        boneValues[3].value
                    );
                
                boneWeights.divideScalar(boneWeights.lengthManhattan());
                
                return [boneIndices, boneWeights];
                
            }
            
            function interpolateLocation(loc1, loc2) {
                var val1 = loc1.value;
                var val2 = loc2.value;
                var a = (1-val2)/(val1-val2);
                if (!smoothInterpolation)
                    a = 0.5;
                //return loc1.clone().multiplyScalar(a).add( loc2.clone().multiplyScalar(1-a) );
                if (isNaN(loc1.clone().lerp(loc2, 1-a).x)) {
                    console.log(loc1, loc2);
                }
                
                return (loc1.clone().lerp(loc2, 1-a));
            }
            
            function generateTexture(metaballs, bounds) {
                // camera setup
                var texRenderTarget = new THREE.WebGLRenderTarget(256, 256);
                var texScene = new THREE.Scene();
                var texCamera = new THREE.OrthographicCamera( 256 / - 2, 256 / 2, 256 / 2, 256 / - 2, 1, 1000 );
				texCamera.position.set(viewerPosition.x, viewerPosition.y, viewerPosition.z);
				texCamera.up = new THREE.Vector3(0, 1, 0);
				texCamera.lookAt(lookAt);
                
                // shader uniforms and metaball data
                var colors = [];
                var texture_weights = [];
                for (var i = 0; i < metaballs.length; i++) {
                    if (metaballs[i].color) {
                        colors.push(metaballs[i].color);
                    } else {
                        colors.push(new THREE.Vector3(1.0,1.0,1.0));
                    }
                    
                    if (metaballs[i].texture_weights) {
                        texture_weights.push(metaballs[i].texture_weights);
                    } else {
                        texture_weights.push(new THREE.Vector4(1.0,0.0,0.0,0.0));
                    }
                }
                
                
                // shader setup
                var geometry = new THREE.PlaneBufferGeometry( 256, 256 );
                var material = new THREE.ShaderMaterial({
					uniforms: {
                        metaballs: new THREE.Uniform(metaballs),
                        metaball_colors: new THREE.Uniform(colors),
                        metaball_texture_weights: new THREE.Uniform(texture_weights),
                        bounds: new THREE.Uniform(new THREE.Vector4(bounds[0], bounds[1], bounds[2], bounds[3])),
                        tex_0: new THREE.Uniform(woodTexture),
                        tex_1: new THREE.Uniform(iceTexture)
                    },
					vertexShader: vertexShader,
					fragmentShader: document.getElementById('textureFragmentShader').textContent.replace("METABALL_COUNT", metaballs.length),
                    side: THREE.DoubleSide
				});
                var plane = new THREE.Mesh( geometry, material );
                texScene.add(plane);
                
                renderer.render(texScene, texCamera, texRenderTarget);
                
                return texRenderTarget.texture;
            }
			
		</script>

		<script id="vertexShader" type="x-shader/x-vertex">
			varying vec3 vertexPosition;
            varying vec2 frag_uv;
			void main() {
				vertexPosition = position;
                frag_uv = uv;
				gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);
			}
		</script>
		<script id="fragmentShader" type="x-shader/x-fragment">
            uniform vec3 metaballs[METABALL_COUNT];
            varying vec3 vertexPosition;
            void main() {
                
                float dist = 0.0;
                for (int i = 0; i < METABALL_COUNT; i++) {
                    //dist += pow(metaballs[i].z, 2.0) / dot(metaballs[i].xy-vertexPosition.xy, metaballs[i].xy-vertexPosition.xy);
                    
                    float distance = dot(metaballs[i].xy-vertexPosition.xy, metaballs[i].xy-vertexPosition.xy);
                    float blobbyness = -0.25;
                    dist += 1.0*exp(blobbyness*distance/(metaballs[i].z*metaballs[i].z)-blobbyness);
                }
                if (dist < 1.0) {
                    gl_FragColor = vec4(dist, 0.0, 0.0, 1.0);
                } else {
                    gl_FragColor = vec4(0.0, 0.0, dist-1.0, 1.0);
                }
                /*
                float dist = 0.0;
                for (int i = 0; i < METABALL_COUNT; i++) {
                    dist = pow(metaballs[i].z, 2.0) / dot(metaballs[i].xy-vertexPosition.xy, metaballs[i].xy-vertexPosition.xy) > 1.0 ? 1.0 : dist;
                }
                if (dist < 1.0) {
                    gl_FragColor = vec4(dist, 0.0, 0.0, 1.0);
                } else {
                    gl_FragColor = vec4(0.0, 0.0, dist, 1.0);
                }*/
			}
		</script>
		<script id="textureFragmentShader" type="x-shader/x-fragment">
            #define METABALL_C METABALL_COUNT
        
            uniform vec3 metaballs[METABALL_C];
            uniform vec3 metaball_colors[METABALL_C];
            uniform vec4 metaball_texture_weights[METABALL_C];

            uniform sampler2D tex_0;
            uniform sampler2D tex_1;
            uniform sampler2D tex_2;
            uniform sampler2D tex_3;
            
            uniform vec4 bounds;
            
            varying vec3 vertexPosition;
            varying vec2 frag_uv;
            
            void main() {
            
                vec2 alteredPosition; 
                // position
                alteredPosition.x = vertexPosition.x + 128.0;
                alteredPosition.y = vertexPosition.y + 128.0;
                
                // scaling
                alteredPosition.x *= bounds.z/256.0;
                alteredPosition.y *= bounds.w/256.0;
                
                alteredPosition.x += bounds.x;
                alteredPosition.y += bounds.y;
                
                float dist = 0.0;
                vec3 color;
                vec4 texture_weights;
                
                for (int i = 0; i < METABALL_C; i++) {
                    float distance = dot(metaballs[i].xy-alteredPosition.xy, metaballs[i].xy-alteredPosition.xy);
                    float blobbyness = -0.25;
                    float val = 1.0*exp(blobbyness*distance/(metaballs[i].z*metaballs[i].z)-blobbyness);
                
                    dist += val;
                    color += val*metaball_colors[i];
                    texture_weights += val*metaball_texture_weights[i];
                }
                
                color /= dist;
                texture_weights /= dist;
                
                // texture UV's, scaled to avoid texture stretching
                float ratio =  bounds.z/bounds.w;
                vec2 uv = frag_uv; 
                if (ratio < 1.0) {
                    uv.x *= ratio;
                }
                if (ratio > 1.0) {
                    uv.y /= ratio;
                }
                
                vec4 texture_colors;
                texture_colors += texture2D(tex_0, uv)*texture_weights.r;
                texture_colors += texture2D(tex_1, uv)*texture_weights.g;
                texture_colors += texture2D(tex_2, uv)*texture_weights.b;
                texture_colors += texture2D(tex_3, uv)*texture_weights.a;
                
                gl_FragColor = texture_colors * vec4(color,1.0)  * (dist-0.5);//*(dist-1.0);
                //gl_FragColor = vec4(uv, 0.0, 1.0);
                //gl_FragColor.r = alteredPosition.x / bounds.z;
                //gl_FragColor.g = alteredPosition.y / bounds.w;
                //gl_FragColor.b = 0.0;
                
                //gl_FragColor.r = vertexPosition.x;
                //gl_FragColor.g = vertexPosition.y;
                //gl_FragColor.b = 0.0;
			}
		</script>
	</head>
	<body onload="onLoad()">
		<div id="myCanvasContainer"></div>
        <div id="dataContainer">
			<span>Vertex count:</span>
			<span>0</span>
            <div></div>
            <span>Triangle count:</span>
			<span>0</span>
		</div>
		<div id="gridStatusContainer">
			<span>(left/right arrows) Grid interval:</span>
			<span>10</span>
		</div>
		<div id="interpolationStatusContainer">
			<span>(up/down arrows) Smooth interpolation:</span>
			<span>true</span>
		</div>
		<div id="wireframeStatusContainer">
			<span>(w) Wireframe:</span>
			<span>false</span>
		</div>
		<div>
			<span>(Space) Pause</span>
		</div>
	</body>
</html>