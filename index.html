<!DOCTYPE>
<html>
	<head>
		<title>Prototype</title>
		<script type="text/javascript" src="three.r87.js"></script>
        <script type="text/javascript" src="bundle.js"></script>
        <script type="text/javascript" src="https://rawgit.com/mrdoob/stats.js/master/build/stats.min.js"></script>
        <script type="text/javascript" src="dat.gui.min.js"></script>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/seedrandom/2.4.3/seedrandom.min.js"></script>
		<script type="text/javascript">
		  
            // CAMERA AND SCENE
			var renderer, scene, camera;
			var lookAt = new THREE.Vector3(0.0, 0.0, 0.0);
			var viewerPosition = new THREE.Vector3(0.0, 0.0, 300.0);
            
            // SHADERS
            var vertexShader;
            var fragmentShader;
            var textureFragmentShader;
            var normalMapFragmentShader;
            
            // GENERATED DATA
            var skeleton;
            var metaballs;
            var polygon;
            var texture;
            
            // GENERATED CREATURE
            var displayCreature = true;
            var creature;
            
            // GENERATED DATA DISPLAY
            var displaySkeleton = true;
            var skeletonhelper;
            
            var displayTexture = true;
            var textureDisplay;
            
            var displayMetaballs = true;
            var metaballDisplay;
            
            var displayOutline = false;
            var lines;
            
            // EYES
            var eyesArray = [];
            var eyeTexture = new THREE.TextureLoader().load( 'eye.png' );
            
            // BASE TEXTURES
            var woodTexture = new THREE.TextureLoader().load( 'wood.jpeg' );
            var iceTexture = new THREE.TextureLoader().load( 'ice.jpeg' );
            
            // SKELETON GENERATION
            var regenerateSeed = true;
            var seed = "Seed";
            
            // OUTLINE GENERATION
            var interval = 5;
            var smoothInterpolation = true;
            
            // MESH GENERATION
            var internalVertices = true;
            var internalVertexDistance = 20;
            
            // SETTINGS
            var wireframe = false;
            var paused = false;
            
            // CLOCK
            var clock = new THREE.Clock();
            
            // INTERFACE
			var stats = new Stats();
			stats.showPanel( 1 ); // 0: fps, 1: ms, 2: mb, 3+: custom
            
            var grabbedBone = false;
            
            // PERFORMANCE TEST
            var numberOfTests = 100;
            var useTestingSkeleton = false;
            var testingSkeletonSegments = 1;
            var testingSkeletonLength = 60;
            var testingSkeletonThickness = 20;
            
            var skeletonTimes = [];
            var metaballTimes = [];
            var outlineTimes = [];
            var textureTimes = [];
            var meshTimes = [];
			
            // TIME
			function millis() {

				return (new Date()).getTime();
			}
			
            // UTILITY
			function toRad(degree) {
			
				return Math.PI * 2 * degree / 360;
			}
		
			function onLoad() {
                // RENDERING SETUP
				var canvasContainer = document.getElementById('myCanvasContainer');
                document.body.appendChild( stats.dom );
                
				var width = 800;
				var height = 800;
				
				renderer = new THREE.WebGLRenderer(); 
				renderer.setSize(width, height);
				canvasContainer.appendChild(renderer.domElement);
				
				scene = new THREE.Scene();
                
				camera = new THREE.OrthographicCamera( width / - 2, width / 2, height / 2, height / - 2, 1, 1000 );
                
				camera.position.set(viewerPosition.x, viewerPosition.y, viewerPosition.z);
				camera.up = new THREE.Vector3(0, 1, 0);
				camera.lookAt(lookAt);
				
                // CUSTOM SHADERS USED
				vertexShader = document.getElementById('vertexShader').textContent;
				fragmentShader = document.getElementById('fragmentShader').textContent;
                textureFragmentShader = document.getElementById('textureFragmentShader');
                normalMapFragmentShader = document.getElementById('normalMapFragmentShader');
                
                createGUI();
                
                //--------------------------
                generateCreature();    
                //--------------------------
                //var light = new THREE.PointLight( 0xffffff, 1, 1000 );
                //light.position.set( 50, 50, 100 );
                //scene.add( light );
                
                var directionalLight = new THREE.DirectionalLight( 0xffffff, 1 );
                directionalLight.position.set(10, 10, 10)
                scene.add( directionalLight );
                
				draw();
                
                // MOVING CREATURE WITH MOUSE
                renderer.domElement.addEventListener( 'mousedown', grabBone, false );
                renderer.domElement.addEventListener( 'mousemove', moveBone, false );
                renderer.domElement.addEventListener( 'mouseup', event => grabbedBone = false, false );
			}
            
            // Detects which bone was grabbed (if any were grabbed) and set it as the presently grabbed bone
            function grabBone(event) {
                var worldX = event.offsetX-400;
                var worldY = 800-event.offsetY-400;
                if (skeleton) {
                    for (var i = 0; i < skeleton.bones.length; i++) {
                        var bone = skeleton.bones[i];
                        var boneloc = bone.getWorldPosition();
                        if (boneloc.distanceTo(new THREE.Vector3(worldX, worldY, 0)) < Math.max(bone.thickness, 20) ) {
                            grabbedBone = bone;
                            return;
                        }
                    }
                }
            }
            
            // Rotates bone to match the direction of cursor. Moves creature in case of root bone.
            function moveBone(event) {
                if (!grabbedBone)
                    return;
                
                var worldX = event.offsetX-400;
                var worldY = 800-event.offsetY-400;
                
                if (grabbedBone.parent.isBone) {
                    var grabbedBoneLoc = grabbedBone.getWorldPosition();
                    
                    var vecToBone = grabbedBoneLoc.clone().sub(grabbedBone.parent.getWorldPosition());
                    var vecToMouse = new THREE.Vector3(worldX, worldY, 0).sub(grabbedBone.parent.getWorldPosition());
                    
                    var angle = Math.atan2(vecToBone.x*vecToMouse.y-vecToBone.y*vecToMouse.x, vecToBone.x*vecToBone.x+vecToMouse.y*vecToMouse.y);
                    grabbedBone.parent.rotation.z += angle;
                } else {
                    grabbedBone.position.x = worldX;
                    grabbedBone.position.y = worldY;
                }
            }
            
            // Creates the GUI in the upper-right corner.
            function createGUI() {
                var gui = new dat.GUI();
                
                var f1 = gui.addFolder('Outline generation');
                
                f1.add(this, 'interval');
                f1.add(this, 'smoothInterpolation');
                
                var f_mesh = gui.addFolder('Mesh generation');
                
                f_mesh.add(this, 'internalVertices');
                f_mesh.add(this, 'internalVertexDistance');
                
                var f2 = gui.addFolder('Display');
                
                var creatureToggle =  f2.add(this, 'displayCreature');
                creatureToggle.onFinishChange(value => creature.visible = value);
                
                var skeletonToggle = f2.add(this, 'displaySkeleton');
                skeletonToggle.onFinishChange(value => skeletonhelper.visible = value);
                
                var textureToggle = f2.add(this, 'displayTexture');
                textureToggle.onFinishChange(value => textureDisplay.visible = value);
                
                var metaballToggle = f2.add(this, 'displayMetaballs');
                metaballToggle.onFinishChange(value => metaballDisplay.visible = value);
                
                var outlineToggle = f2.add(this, 'displayOutline');
                outlineToggle.onFinishChange(value => lines.visible = value);
                
                var f3 = gui.addFolder('Performance Test');
                f3.add(this, 'useTestingSkeleton');
                    
                var f4 = f3.addFolder('Testing Skeleton');
                f4.add(this, 'testingSkeletonSegments').name("segments");
                f4.add(this, 'testingSkeletonLength').name("length");
                f4.add(this, 'testingSkeletonThickness').name("thickness");
                
                f3.add(this, 'numberOfTests');
                f3.add(this, 'performanceTest');
                
                
                var wireToggle = gui.add(this, 'wireframe');
                wireToggle.onFinishChange(value => creature.material.wireframe = value);
                
                gui.add(this, 'regenerateSeed');
                gui.add(this, 'seed').listen();
                gui.add(this, 'paused');
                gui.add(this, 'generateCreature');
            }
			
            // Animation and render loop
			function draw() {
				requestAnimationFrame(draw);
                
                stats.begin();
				
                var dt = clock.getDelta();
                
                if (!paused) {
                    
                    for (var i = 1; i < skeleton.bones.length; i++) {
                        if (!skeleton.bones[i].doNotAnimate)
                            skeleton.bones[i].rotation.z = Math.sin(clock.getElapsedTime()*(i/0.23+1)/10.0);
                    }
                }
                
				renderer.render(scene, camera);
                
                stats.end();
			}
            
            // Tests performanve. Results are output to console.
            function performanceTest() {
                skeletonTimes = [];
                metaballTimes = [];
                outlineTimes = [];
                textureTimes = [];
                meshTimes = [];
                for (var i = 0; i < numberOfTests; i++) {
                    generateCreature();
                }
                function calculateAverage (arr) {
                    var sum = 0;
                    for (var i = 0; i < numberOfTests; i++) {
                        sum += arr[i];
                    }
                    return sum / numberOfTests;
                }

                console.log("skeleton",calculateAverage(skeletonTimes)*1000);
                console.log("metaball",calculateAverage(metaballTimes)*1000);
                console.log("outline",calculateAverage(outlineTimes)*1000);
                console.log("texture",calculateAverage(textureTimes)*1000);
                console.log("mesh",calculateAverage(meshTimes)*1000);
            }
            
            // Removes old creature and generate new creature.
            function generateCreature() {
                scene.remove(creature); // remove this line to generate multiple creatures
                scene.remove(lines);
                scene.remove(skeletonhelper);
                scene.remove(metaballDisplay);
                scene.remove(textureDisplay);
                
                var timer = new THREE.Clock();
                timer.getElapsedTime();
                
                // SKELETON
                console.log("generating skeleton");
                skeleton = generateSkeleton();
                skeletonTimes.push(timer.getElapsedTime());
                
                // METABALLS
                console.log("generating metaballs");
                metaballs = [];
                generateMetaballs(metaballs, skeleton.bones[0]);
                
                metaballTimes.push(timer.getElapsedTime());
                
                // OUTLINE
                console.log("generating polygon");
                polygon = generatePolygon(metaballs);
                outlineTimes.push(timer.getElapsedTime());
                
                lines = new THREE.Line( new THREE.Geometry, new THREE.LineBasicMaterial({color: 0xff00ff00}) );
                lines.geometry.vertices = polygon.slice(0);
                lines.geometry.vertices.push(lines.geometry.vertices[0]);
                lines.geometry.verticesNeedUpdate = true;
                lines.position.z += 1;
                lines.position.x += 100;
                
                scene.add(lines);
                lines.visible = displayOutline;
                
                // TEXTURE
                console.log("generating texture");
                // bounding box of mesh
                var lowestX = polygon[0].x, lowestY = polygon[0].y, highestX = polygon[0].x, highestY = polygon[0].y;
                for (var i = 0; i < polygon.length; i++) {
                    lowestX = Math.min(lowestX, polygon[i].x)
                    lowestY = Math.min(lowestY, polygon[i].y)
                    highestX = Math.max(highestX, polygon[i].x)
                    highestY = Math.max(highestY, polygon[i].y)
                }
                textures = generateTexture(metaballs, [lowestX, lowestY, highestX-lowestX, highestY-lowestY]);
                textureTimes.push(timer.getElapsedTime());
                
                // MESH
                console.log("generating mesh");
                creature = generateMesh(textures, polygon, metaballs, skeleton);
                meshTimes.push(timer.getElapsedTime());
                
                skeletonhelper = new THREE.SkeletonHelper( creature );
                scene.add(creature);
                creature.visible = displayCreature;
                
                scene.add(skeletonhelper);
                skeletonhelper.visible = displaySkeleton;
                
                // METABALL DISPLAY
                var geometry = new THREE.PlaneBufferGeometry( 700, 700 );
                var material = new THREE.ShaderMaterial({
					uniforms: {
                        metaballs: new THREE.Uniform(metaballs)
                    },
					vertexShader: vertexShader,
					fragmentShader: fragmentShader.replace("METABALL_COUNT", metaballs.length),
                    side: THREE.DoubleSide
				});
                metaballDisplay = new THREE.Mesh( geometry, material );
                metaballDisplay.position.z = -1;
                metaballDisplay.position.x += 100;
                scene.add( metaballDisplay );
                metaballDisplay.visible = displayMetaballs;
                
                // TEXTURE DISPLAY
                var geometry = new THREE.PlaneBufferGeometry( 256, 256 );
                var material = new THREE.MeshBasicMaterial({map: textures[1]});
                textureDisplay = new THREE.Mesh( geometry, material );
                textureDisplay.position.x -= 400-128;
                textureDisplay.position.y += 250-128;
                scene.add( textureDisplay );
                textureDisplay.visible = displayTexture;
            }
            
            function generateSkeleton() {
                
                // Essentially creates a long worm.
                if (useTestingSkeleton) {
                    var bone = new THREE.Bone();
                    bone.thickness = 0;
                    var bones = [bone];
                    
                    for (var i = 0; i < testingSkeletonSegments; i++) {
                        bone = new THREE.Bone();
                        bone.thickness = testingSkeletonThickness;
                        bone.position.x = testingSkeletonLength;
                        
                        bones[bones.length-1].add(bone);
                        bones.push(bone);
                    }
                    return new THREE.Skeleton(bones);
                }
                
                // SPINE
                if (regenerateSeed) {
                    var symbols = "abcdefghijklmnopqrstuvwxyz0123456789";
                    seed = "";
                    for (var i = 0; i < 10; i++) {
                        seed += symbols[Math.floor(Math.random()*symbols.length)];
                    }
                }
                
                var obj = Math.seedrandom(seed, { pass: function(prng, seed) {
                    return { random: prng, seed: seed };
                }});
                
                var random = obj.random;
                console.log(obj.seed);
                
                var spineSegments = Math.round(3+random()*3);
                
                var skeleton = [];
                var spine = [];
                var rootBone = new THREE.Bone();
                rootBone.thickness = 0;
                spine.push(rootBone);
                
                for (var i = 1; i < spineSegments; i++) {
                    var spineSegment = new THREE.Bone();
                    
                    spineSegment.thickness = 10+random()*30;
                    spineSegment.position.y = 50+random()*50;
                    var a = random();
                    spineSegment.texture_weights = new THREE.Vector4(a, 1.0-a, 0.0, 0.0);
                    spineSegment.color = new THREE.Vector3(random(), random(), random());
                    spineSegment.multiplier = 1+random()*0.6;
                    
                    spine[i-1].add(spineSegment);
                    spine.push(spineSegment);
                }
                skeleton.push(...spine);
                skeleton[skeleton.length-1].doNotAnimate = true;
                
                // EYES
                var eyes = Math.floor(1+random()*7);
                var eyeSize = skeleton[skeleton.length-1].thickness*(0.5+random()*0.5);
                var eyeDistance = skeleton[skeleton.length-1].thickness - eyeSize/2;
                    
                var eyeMesh = new THREE.Mesh( new THREE.PlaneGeometry( eyeSize, eyeSize ), new THREE.MeshBasicMaterial({map: eyeTexture, side: THREE.DoubleSide, transparent:true, opacity: 0.8}) );
                
                // Eye placement
                for (var i = 0; i < eyes; i++) {
                    var angle = Math.PI/eyes*i*2.0;
                    if (eyes % 2 == 1) {
                        angle += Math.PI*0.5;
                    }
                    var x = Math.cos(angle)*eyeDistance;
                    var y = Math.sin(angle)*eyeDistance;
                    
                    var eye = eyeMesh.clone();
                    eye.position.x = x;
                    eye.position.y = y;
                    eye.position.z = 1;
                    skeleton[skeleton.length-1].add(eye);
                    eyesArray.push(eye);
                }
                
                
                // LIMBS
                for (var i = 0; i < spineSegments; i++) {
                    if (random() > 0.5) {
                        var limbSegments = Math.round(2+random()*2);
                        
                        var limbSegmentLengths = [];
                        var limbSegmentThicknesses = [];
                        var limbSegmentMultipliers = [];
                        
                        for (var j = 0; j < limbSegments; j++) {
                            limbSegmentLengths.push(50+random()*30);
                            limbSegmentThicknesses.push(5+random()*10);
                            limbSegmentMultipliers.push(1+random()*0.6);
                        }
                        limbSegmentThicknesses[0] = 0;
                        
                        for (var dir = -1; dir < 2; dir+=2) {
                            var limb = [];
                            
                            // Limb joint to attach the limb to.
                            var limbJoint = new THREE.Bone();
                            
                            // Limbs placed at joint between spine segments. Needs to not be inside either.
                            if (i < spineSegments-1) {
                                limbJoint.position.x = dir*Math.max(spine[i].thickness, spine[i+1].thickness)*1.1;
                            } else {
                                limbJoint.position.x = dir*spine[i].thickness*1.1;
                            }
                            
                            limbJoint.thickness = limbSegmentThicknesses[0];
                            limb.push(limbJoint);
                            spine[i].add(limbJoint);
                            
                            // Limb itself
                            for (var j = 1; j < limbSegments; j++) {
                                var limbSegment = new THREE.Bone();

                                limbSegment.thickness = limbSegmentThicknesses[j];
                                limbSegment.position.x = dir*limbSegmentLengths[j];
                                limbSegment.color = new THREE.Vector3(random(), random(), random());
                                limbSegment.multiplier = limbSegmentMultipliers[j];

                                limb[j-1].add(limbSegment);
                                limb.push(limbSegment);
                            }
                            
                            skeleton.push(...limb);
                        }
                        
                    }
                }
                
                return new THREE.Skeleton(skeleton);
            }
            
            function generateMetaballs(metaballs, bone, parent) {
                
                // not a root bone or bone to be ignored
                if (parent !== undefined && bone.thickness > 0.0) {
                    
                    // Balls placed between these two points.
                    var boneLocation = bone.getWorldPosition();
                    var parentLocation = parent.getWorldPosition();

                    var mult = 1.6;
                    if (bone.multiplier) {
                        mult = bone.multiplier;
                    }
                    var thicknessMult = mult/Math.sqrt(2*Math.log(mult*mult)+1);
                    
                    // Amount of placed balls.
                    var subballs = Math.ceil(boneLocation.distanceTo(parentLocation)/(bone.thickness*2.97)*mult);
                    
                    
                    // Places balls at both ends of the bone.
                    for (var i = 0; i <= subballs; i++) {
                        var thickness = bone.thickness*thicknessMult;
                        
                        var alpha = i/subballs;
                        
                        if (i == subballs && parent.parent !== null)
                            alpha = (i-0.5)/subballs;
                        
                        var ball = boneLocation.clone().lerp(parentLocation, alpha);
                        ball.boneID = skeleton.bones.indexOf(parent);
                        ball.z = thickness;
                        
                        if (bone.color) {
                            if (parent.color) {
                                ball.color = bone.color.clone().lerp(parent.color, alpha);
                            } else {
                                ball.color = bone.color;
                            }
                        }
                        if (bone.texture_weights) {
                            ball.texture_weights = bone.texture_weights;
                        }
                        
                        metaballs.push(ball);
                    }
                }
                
                // Recursive call to all bones.
                bone.children.forEach(function(child) {
                    generateMetaballs(metaballs, child, bone);
                });
            }
            
            // ENUM OF MOVEMENT DIRECTIONS 
            const UP = 0;
            const DOWN = 1;
            const LEFT = 2;
            const RIGHT = 3;
            
            // Which side to use for placing new vertex.
            function nextVertex(dir, topLeft, topRight, bottomLeft, bottomRight) {
                if (dir == UP) {
                    return interpolateLocation(topLeft, topRight);
                }
                if (dir == DOWN) {
                    return interpolateLocation(bottomLeft, bottomRight);
                }
                if (dir == LEFT) {
                    return interpolateLocation(topLeft, bottomLeft);
                }
                if (dir == RIGHT) {
                    return interpolateLocation(topRight, bottomRight);
                }
            }
            
            // Finds outline of shape defined by metaballs, variant of marching squares
            function generatePolygon(metaballs) {
                
                // Picks highest metaball
                var start = metaballs[0];
                for (var i = 1; i < metaballs.length; i++) {
                    if (metaballs[i].y > start.y) {
                        start = metaballs[i];
                    }
                }
                start = start.clone();
                
                start.z = 0;
                
                // Moves upward until finds value below 1, indicating edge.
                while (calculateValueAt(start, metaballs) >= 1.0) {
                    start.add(new THREE.Vector3(0.0, interval));
                }
                
                // Values at the corners of the squares
                var topLeft, topRight, bottomLeft, bottomRight;
                
                topRight = addValueTo(start.clone(), metaballs);
                bottomRight = addValueTo(start.clone().add(new THREE.Vector3(0.0, -interval)), metaballs);
                
                // Begins as if coming from the right
                var prev = RIGHT;
                
                // Generated vertices. Ordered.
                var vertices = [];

                passedStart = false;
                
                // Does not use the float coordinate values for determining return to start. May cause mismatch otherwise.
                var x = -1;
                var y = 0;
                
                while (true) {
                    if (prev == RIGHT) {x++;}
                    if (prev == LEFT) {x--;}
                    if (prev == UP) {y++;}
                    if (prev == DOWN) {y--}
                    
                    if (prev == RIGHT && x == 0 && y == 0) {
                        if (passedStart) {
                            break;
                        }
                        passedStart = true;
                    }
                    
                    // 16+4 cases. sorted by entry direction.
                    // All reuse two already calculated values.
                    // Interpolates locations of found vertices.
                    if (prev == UP) {
                        bottomLeft = topLeft;
                        bottomRight = topRight;
                        topLeft = addValueTo(bottomLeft.clone().add(new THREE.Vector3(0.0, interval)), metaballs);
                        topRight = addValueTo(bottomRight.clone().add(new THREE.Vector3(0.0, interval)), metaballs);
                        
                        var tl = topLeft.value >= 1.0;
                        var tr = topRight.value >= 1.0;
                        var bl = bottomLeft.value >= 1.0;
                        var br = bottomRight.value >= 1.0;
                        
                        if (tl && tr) {
                            prev = LEFT;
                            vertices.push(interpolateLocation(topLeft, bottomLeft));
                            continue;
                        }
                        if (!tl && tr) {
                            prev = UP;
                            vertices.push(nextVertex(prev, topLeft, topRight, bottomLeft, bottomRight));
                            continue;
                        }
                        if (!tl && !tr) {
                            prev = RIGHT;
                            vertices.push(nextVertex(prev, topLeft, topRight, bottomLeft, bottomRight));
                            continue;
                        }
                        if (tl && !tr) {
                            var middle = addValueTo(topLeft.clone().add(bottomRight).divideScalar(2.0), metaballs);
                            if (middle.value >= 1.0) {
                                prev = LEFT;
                                vertices.push(nextVertex(prev, topLeft, topRight, bottomLeft, bottomRight));
                            } else {
                                prev = RIGHT;
                                vertices.push(nextVertex(prev, topLeft, topRight, bottomLeft, bottomRight));
                            }
                            continue;
                        }
                    }
                    
                    if (prev == DOWN) {
                        topLeft = bottomLeft;
                        topRight = bottomRight;
                        bottomLeft = addValueTo(topLeft.clone().add(new THREE.Vector3(0.0, -interval)), metaballs);
                        bottomRight = addValueTo(topLeft.clone().add(new THREE.Vector3(interval, -interval)), metaballs);
                        
                        var tl = topLeft.value >= 1.0;
                        var tr = topRight.value >= 1.0;
                        var bl = bottomLeft.value >= 1.0;
                        var br = bottomRight.value >= 1.0;
                        
                        if (bl && br) {
                            prev = RIGHT;
                            vertices.push(nextVertex(prev, topLeft, topRight, bottomLeft, bottomRight));
                            continue;
                        }
                        if (!bl && !br) {
                            prev = LEFT;
                            vertices.push(nextVertex(prev, topLeft, topRight, bottomLeft, bottomRight));
                            continue;
                        }
                        if (bl && !br) {
                            prev = DOWN;
                            vertices.push(nextVertex(prev, topLeft, topRight, bottomLeft, bottomRight));
                            continue;
                        }
                        if (!bl && br) {
                            var middle = addValueTo(topLeft.clone().add(bottomRight).divideScalar(2.0), metaballs);
                            if (middle.value >= 1.0) {
                                prev = RIGHT;
                                vertices.push(nextVertex(prev, topLeft, topRight, bottomLeft, bottomRight));
                            } else {
                                prev = LEFT;
                                vertices.push(nextVertex(prev, topLeft, topRight, bottomLeft, bottomRight));
                            }
                            continue;
                        }
                    }
                    
                    if (prev == LEFT) {
                        topRight = topLeft;
                        bottomRight = bottomLeft;
                        topLeft = addValueTo(topRight.clone().add(new THREE.Vector3(-interval, 0.0)), metaballs);
                        bottomLeft = addValueTo(bottomRight.clone().add(new THREE.Vector3(-interval, 0.0)), metaballs);
                        
                        var tl = topLeft.value >= 1.0;
                        var tr = topRight.value >= 1.0;
                        var bl = bottomLeft.value >= 1.0;
                        var br = bottomRight.value >= 1.0;
                        
                        if (tl && bl) {
                            prev = DOWN;
                            vertices.push(nextVertex(prev, topLeft, topRight, bottomLeft, bottomRight));
                            continue;
                        }
                        if (!tl && !bl) {
                            prev = UP;
                            vertices.push(nextVertex(prev, topLeft, topRight, bottomLeft, bottomRight));
                            continue;
                        }
                        if (tl && !bl) {
                            prev = LEFT;
                            vertices.push(nextVertex(prev, topLeft, topRight, bottomLeft, bottomRight));
                            continue;
                        }
                        if (!tl && bl) {
                            var middle = addValueTo(topLeft.clone().add(bottomRight).divideScalar(2.0), metaballs);
                            if (middle.value >= 1.0) {
                                prev = DOWN;
                                vertices.push(nextVertex(prev, topLeft, topRight, bottomLeft, bottomRight));
                            } else {
                                prev = UP;
                                vertices.push(nextVertex(prev, topLeft, topRight, bottomLeft, bottomRight));
                            }
                            continue;
                        }
                    }
                    
                    if (prev == RIGHT) {
                        topLeft = topRight;
                        bottomLeft = bottomRight;
                        topRight = addValueTo(topLeft.clone().add(new THREE.Vector3(interval, 0.0)), metaballs);
                        bottomRight = addValueTo(bottomLeft.clone().add(new THREE.Vector3(interval, 0.0)), metaballs);
                        
                        var tl = topLeft.value >= 1.0;
                        var tr = topRight.value >= 1.0;
                        var bl = bottomLeft.value >= 1.0;
                        var br = bottomRight.value >= 1.0;
                        
                        if (tr && br) {
                            prev = UP;
                            vertices.push(nextVertex(prev, topLeft, topRight, bottomLeft, bottomRight));
                            continue;
                        }
                        if (!tr && !br) {
                            prev = DOWN;
                            vertices.push(nextVertex(prev, topLeft, topRight, bottomLeft, bottomRight));
                            continue;
                        }
                        if (!tr && br) {
                            prev = RIGHT;
                            vertices.push(nextVertex(prev, topLeft, topRight, bottomLeft, bottomRight));
                            continue;
                        }
                        if (tr && !br) {
                            var middle = addValueTo(topLeft.clone().add(bottomRight).divideScalar(2.0), metaballs);
                            if (middle.value >= 1.0) {
                                prev = UP;
                                vertices.push(nextVertex(prev, topLeft, topRight, bottomLeft, bottomRight));
                            } else {
                                prev = DOWN;
                                vertices.push(nextVertex(prev, topLeft, topRight, bottomLeft, bottomRight));
                            }
                            continue;
                        }
                    }
                }
                
                return vertices;
            }
            
            // calculates location of outline based on two values and positions
            function interpolateLocation(loc1, loc2) {
                var val1 = loc1.value;
                var val2 = loc2.value;
                var a = (1-val2)/(val1-val2);
                if (!smoothInterpolation)
                    a = 0.5;
                
                if (isNaN(loc1.clone().lerp(loc2, 1-a).x)) {
                    console.log(loc1, loc2);
                }
                
                return (loc1.clone().lerp(loc2, 1-a));
            }
            
            // Generates mesh, determines z's and skinning data.
            function generateMesh(textures, polygon, metaballs, skeleton) {
                
                var triangles = new THREE.SkinnedMesh( new THREE.Geometry, new THREE.MeshStandardMaterial({wireframe: wireframe, skinning:true, map: textures[0], normalMap: textures[1], metalness: 0.0, roughness: 0.9}) );
                triangles.geometry.vertices = polygon.slice(0);

                // vertices
                var points = [];

                for (var i = 0; i < polygon.length; i++) {
                    points.push([polygon[i].x, polygon[i].y]);
                }
                
                // area covered by mesh
                var lowestX = polygon[0].x, lowestY = polygon[0].y, highestX = polygon[0].x, highestY = polygon[0].y;
                for (var i = 0; i < polygon.length; i++) {
                    lowestX = Math.min(lowestX, polygon[i].x)
                    lowestY = Math.min(lowestY, polygon[i].y)
                    highestX = Math.max(highestX, polygon[i].x)
                    highestY = Math.max(highestY, polygon[i].y)
                }
                
                // adds points in skewed grid to fill out interior, checks if point would be outside of surface
                if (internalVertices) {
                    var offset = highestY-lowestY;
                    for (var x = lowestX+0.01; x < highestX+offset; x+=internalVertexDistance+0.1711) {
                        for (var y = lowestY+0.01; y < highestY; y+=internalVertexDistance+0.1711) {
                            var skew = (y-lowestY)/2;
                            if (polygonContainsVertex({x: x-skew, y: y}, polygon)) {
                                triangles.geometry.vertices.push(new THREE.Vector3(x-skew, y, 0));
                                points.push([x-skew, y])
                            }
                        }
                    }
                }
                
                // edges for cdt2d
                var edges = [];
                for (var i = 0; i < polygon.length; i++) {
                    var j = (i + 1) % polygon.length;
                    edges.push([i, j]);
                }
                
                // generates faces
                var faces = cdt2d(points, edges, {exterior: false});
                
                // generates uv's
                triangles.geometry.faceVertexUvs = [[]];
                
                width = highestX - lowestX;
                height = highestY - lowestY;
                function mapUV(vertexI) {
                    var vertex = triangles.geometry.vertices[vertexI];
                    return new THREE.Vector2( (vertex.x-lowestX)/width, (vertex.y-lowestY)/height );
                }
                
                for (var i = 0; i < faces.length; i++) {
                    triangles.geometry.faces.push( new THREE.Face3(faces[i][0],faces[i][1],faces[i][2]) );
                    triangles.geometry.faceVertexUvs[0].push([mapUV(faces[i][0]),mapUV(faces[i][1]),mapUV(faces[i][2])]);
                }
                
                triangles.geometry.computeVertexNormals();
                
                // skinning and z
                triangles.add(skeleton.bones[0]);
                for (var i = 0; i < triangles.geometry.vertices.length; i++) {
                    var data = calculateSkinningData(triangles.geometry.vertices[i], metaballs, skeleton);
                    triangles.geometry.skinIndices.push( data[0] );
                    triangles.geometry.skinWeights.push( data[1] );
                    
                    triangles.geometry.vertices[i].z = (triangles.geometry.vertices[i].y-lowestY)/height;
                }
                triangles.bind( skeleton );
                
                console.log(triangles.geometry);
                
                return triangles;
            }
            
            // Checks if vertex is inside polygon or outside
            function polygonContainsVertex(vertex, polygon) {
                var i = 0, j = polygon.length - 1;
                var contains = false;
                
                for (var i = 0, j = 1; i < polygon.length; i++) {
                    j = (i+1) % polygon.length;
                    var a = polygon[i];
                    var b = polygon[j];
                    if (a.y < b.y) {
                        a = polygon[j];
                        b = polygon[i];
                    }
                    if (vertex.y < a.y && vertex.y >= b.y) {
                        if (vertex.x < (b.x-a.x)/(b.y-a.y)*(vertex.y-a.y)+a.x )
                            contains = !contains;
                    }
                }
                return contains;
            }

            
            function addValueTo(vec, metaballs) {
                vec.value = calculateValueAt(vec, metaballs);
                return vec;
            }
            
            // calculates effect of single metaball at point
            function calculateMetaballValue(x, y, metaball) {
                var distance = Math.pow(metaball.x-x, 2.0)+Math.pow(metaball.y-y, 2.0);
                var blobbyness = -0.5;
                return 1.0*Math.exp(blobbyness*distance/(metaball.z*metaball.z)-blobbyness);
                
            }
            
            // calculates effect of all metaballs combined at point
            function calculateValueAt(c, metaballs) {
                var x = c.x;
                var y = c.y;
                var val = 0.0;
                for (var i = 0; i < metaballs.length; i++) {
                    var metaball = metaballs[i];
                    var addedVal = calculateMetaballValue(x, y, metaball);
                    if (!isFinite(addedVal)) {
                        addedVal = 10000.0;
                    }
                    val += addedVal;
                }
                return val;
            }
            
            // calculates skinning data of vertex
            function calculateSkinningData(v, metaballs, skeleton) {
                var x = v.x;
                var y = v.y;
                
                boneValues = []
                for (var i = 0; i < skeleton.bones.length; i++) [boneValues.push({id:i,value:0})]
                
                for (var i = 0; i < metaballs.length; i++) {
                    var metaball = metaballs[i];
                    var addedVal = calculateMetaballValue(x, y, metaball);
                    if (!isFinite(addedVal))
                        addedVal = 10000.0;
                    
                    boneValues[metaball.boneID].value += addedVal;
                }
                
                // picks 4 bones that affect the vexrtex the most
                boneValues.sort(function(a, b){return b.value - a.value});
                
                // fixes error when the are less than 4 bones
                while (boneValues.length < 4) {
                    boneValues.push({id:0,value:0});
                }
                
                boneIndices = new THREE.Vector4( 
                        boneValues[0].id,
                        boneValues[1].id, 
                        boneValues[2].id, 
                        boneValues[3].id
                    );
                
                boneWeights = new THREE.Vector4( 
                        boneValues[0].value,
                        boneValues[1].value, 
                        boneValues[2].value, 
                        boneValues[3].value
                    );
                // scales weights
                boneWeights.divideScalar(boneWeights.lengthManhattan());
                
                return [boneIndices, boneWeights];
                
            }
            
            function generateTexture(metaballs, bounds) {
                // camera setup
                var texRenderTarget = new THREE.WebGLRenderTarget(256, 256);
                var texScene = new THREE.Scene();
                var texCamera = new THREE.OrthographicCamera( 256 / - 2, 256 / 2, 256 / 2, 256 / - 2, 1, 1000 );
				texCamera.position.set(0, 0, 30);
                
                // shader uniforms and metaball data converted to form usable with Three.js
                var colors = [];
                var texture_weights = [];
                for (var i = 0; i < metaballs.length; i++) {
                    if (metaballs[i].color) {
                        colors.push(metaballs[i].color);
                    } else {
                        colors.push(new THREE.Vector3(1.0,1.0,1.0));
                    }
                    
                    if (metaballs[i].texture_weights) {
                        texture_weights.push(metaballs[i].texture_weights);
                    } else {
                        texture_weights.push(new THREE.Vector4(1.0,0.0,0.0,0.0));
                    }
                }
                
                
                // shader setup
                var geometry = new THREE.PlaneBufferGeometry( 256, 256 );
                var material = new THREE.ShaderMaterial({
					uniforms: {
                        metaballs: new THREE.Uniform(metaballs),
                        metaball_colors: new THREE.Uniform(colors),
                        metaball_texture_weights: new THREE.Uniform(texture_weights),
                        bounds: new THREE.Uniform(new THREE.Vector4(bounds[0], bounds[1], bounds[2], bounds[3])),
                        tex_0: new THREE.Uniform(woodTexture),
                        tex_1: new THREE.Uniform(iceTexture)
                    },
					vertexShader: vertexShader,
					fragmentShader: textureFragmentShader.textContent.replace("METABALL_COUNT", metaballs.length),
                    side: THREE.DoubleSide
				});
                var plane = new THREE.Mesh( geometry, material );
                
                texScene.add(plane);
                renderer.render(texScene, texCamera, texRenderTarget);
                texScene.remove(plane);
                
                var normalMapRenderTarget = new THREE.WebGLRenderTarget(256, 256);
                
                var geometry = new THREE.PlaneBufferGeometry( 256, 256 );
                var material = new THREE.ShaderMaterial({
					uniforms: {
                        metaballs: new THREE.Uniform(metaballs),
                        bounds: new THREE.Uniform(new THREE.Vector4(bounds[0], bounds[1], bounds[2], bounds[3])),
                    },
					vertexShader: vertexShader,
					fragmentShader: normalMapFragmentShader.textContent.replace("METABALL_COUNT", metaballs.length),
                    side: THREE.DoubleSide
				});
                var plane = new THREE.Mesh( geometry, material );
                
                texScene.add(plane);
                renderer.render(texScene, texCamera, normalMapRenderTarget);
                
                return [texRenderTarget.texture, normalMapRenderTarget.texture];
            }
			
		</script>

		<script id="vertexShader" type="x-shader/x-vertex">
			varying vec3 vertexPosition;
            varying vec2 frag_uv;
			void main() {
				vertexPosition = position;
                frag_uv = uv;
				gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);
			}
		</script>
		<script id="fragmentShader" type="x-shader/x-fragment">
            #define METABALL_C METABALL_COUNT
        
            uniform vec3 metaballs[METABALL_C];
            varying vec3 vertexPosition;
            void main() {
                
                float dist = 0.0;
                float insideBall = 0.0;
                for (int i = 0; i < METABALL_C; i++) {
                    
                    float distance = dot(metaballs[i].xy-vertexPosition.xy, metaballs[i].xy-vertexPosition.xy);
                    float blobbyness = -0.5;
                    float extraVal = 1.0*exp(blobbyness*distance/(metaballs[i].z*metaballs[i].z)-blobbyness);
                    dist += extraVal;
                    insideBall = extraVal > 1.0 ? 1.0 : insideBall;
                    
                    
                }
                if (dist < 1.0) {
                    gl_FragColor = vec4(dist, 0.0, 0.0, 1.0);
                } else {
                    gl_FragColor = vec4(0.0, 0.0, dist-1.0, 1.0);
                }
                
                /* Uncomment to show whether location is actually inside radius of metaball
                if (insideBall > 0.5) {
                    gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);
                }
                */
			}
		</script>
		<script id="normalMapFragmentShader" type="x-shader/x-fragment">
            #define METABALL_C METABALL_COUNT
        
            uniform vec3 metaballs[METABALL_C];
            uniform vec4 bounds;
            varying vec2 frag_uv;
            
            void main() {
                
                // coordinates in metaball space
                vec2 alteredPosition; 
                alteredPosition.x = bounds.x + frag_uv.x * bounds.z;
                alteredPosition.y = bounds.y + frag_uv.y * bounds.w;
                
                float top = 0.0;
                float bottom = 0.0;
                float left = 0.0;
                float right = 0.0;
                
                float blobbyness = -0.5;
                vec2 hgap = vec2(0.1, 0.0);
                vec2 vgap = vec2(0.0, 0.1);
                
                float sum = 0.0;
                
                for (int i = 0; i < METABALL_C; i++) {
                    float distance = dot(metaballs[i].xy-alteredPosition.xy-hgap, metaballs[i].xy-alteredPosition.xy-hgap);
                    float val = 1.0*exp(blobbyness*distance/(metaballs[i].z*metaballs[i].z)-blobbyness)*metaballs[i].z;
                    
                    left += val;
                
                    distance = dot(metaballs[i].xy-alteredPosition.xy+hgap, metaballs[i].xy-alteredPosition.xy+hgap);
                    val = 1.0*exp(blobbyness*distance/(metaballs[i].z*metaballs[i].z)-blobbyness)*metaballs[i].z;
                    
                    right += val;
                    
                    distance = dot(metaballs[i].xy-alteredPosition.xy-vgap, metaballs[i].xy-alteredPosition.xy-vgap);
                    val = 1.0*exp(blobbyness*distance/(metaballs[i].z*metaballs[i].z)-blobbyness)*metaballs[i].z;
                    
                    bottom += val;
                    
                    distance = dot(metaballs[i].xy-alteredPosition.xy+vgap, metaballs[i].xy-alteredPosition.xy+vgap);
                    val = 1.0*exp(blobbyness*distance/(metaballs[i].z*metaballs[i].z)-blobbyness)*metaballs[i].z;
                    
                    top += val;
                    
                    distance = dot(metaballs[i].xy-alteredPosition.xy, metaballs[i].xy-alteredPosition.xy);
                    val = 1.0*exp(blobbyness*distance/(metaballs[i].z*metaballs[i].z)-blobbyness);
                    sum += val;
                }
                
                
                float h = (right-left);
                float v = (top-bottom);
                
                vec3 hvz = normalize(vec3(h,v,(sum-1.0)*0.7))+vec3(0.5,0.5,0.5);
                
                //hvz = vec3(vec2(h,v)+vec2(0.5,0.5), 1.0);
                
                gl_FragColor = vec4(hvz, 1.0);
			}
		</script>
		<script id="textureFragmentShader" type="x-shader/x-fragment">
            #define METABALL_C METABALL_COUNT
        
            uniform vec3 metaballs[METABALL_C];
            uniform vec3 metaball_colors[METABALL_C];
            uniform vec4 metaball_texture_weights[METABALL_C];

            uniform sampler2D tex_0;
            uniform sampler2D tex_1;
            uniform sampler2D tex_2;
            uniform sampler2D tex_3;
            
            uniform vec4 bounds;
            
            varying vec2 frag_uv;
            
            void main() {
                
                // coordinates in metaball space
                vec2 alteredPosition; 
                alteredPosition.x = bounds.x + frag_uv.x * bounds.z;
                alteredPosition.y = bounds.y + frag_uv.y * bounds.w;
                
                // variables for drawing
                float dist = 0.0;
                vec3 color;
                vec4 texture_weights;
                
                for (int i = 0; i < METABALL_C; i++) {
                    float distance = dot(metaballs[i].xy-alteredPosition.xy, metaballs[i].xy-alteredPosition.xy);
                    float blobbyness = -0.5;
                    float val = 1.0*exp(blobbyness*distance/(metaballs[i].z*metaballs[i].z)-blobbyness);
                
                    dist += val;
                    color += val*metaball_colors[i];
                    texture_weights += val*metaball_texture_weights[i];
                }
                
                color /= dist;
                texture_weights /= dist;
                
                // texture UV's for base textures, scaled to avoid texture stretching
                float ratio =  bounds.z/bounds.w;
                vec2 uv = frag_uv; 
                if (ratio < 1.0) {
                    uv.x *= ratio;
                }
                if (ratio > 1.0) {
                    uv.y /= ratio;
                }
                
                vec4 texture_colors;
                texture_colors += texture2D(tex_0, uv)*texture_weights.r;
                texture_colors += texture2D(tex_1, uv)*texture_weights.g;
                texture_colors += texture2D(tex_2, uv)*texture_weights.b;
                texture_colors += texture2D(tex_3, uv)*texture_weights.a;
                
                gl_FragColor = vec4(color,1.0) * texture_colors * 1.5;// * (dist-0.25); vec4(color,1.0) * 
			}
		</script>
	</head>
	<body onload="onLoad()">
		<div id="myCanvasContainer"></div>
	</body>
</html>