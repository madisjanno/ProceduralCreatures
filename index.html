<!DOCTYPE>
<html>
	<head>
		<title>Prototype</title>
		<script type="text/javascript" src="three.r87.js"></script>
        <script type="text/javascript" src="bundle.js"></script>
        <script type="text/javascript" src="http://rawgit.com/mrdoob/stats.js/master/build/stats.min.js"></script>
		<script type="text/javascript">
		
			var renderer, scene, camera;
			var lookAt = new THREE.Vector3(0.0, 0.0, 0.0);
			var viewerPosition = new THREE.Vector3(0.0, 0.0, 30.0);
            
            var metaballs = [];
            
            var lines;
            var triangles;
            
            var interval = 10;
            var smoothInterpolation = true;
            var wireframe = false;
            var paused = false;
            
            var clock = new THREE.Clock();
            
			var stats = new Stats();
			stats.showPanel( 1 ); // 0: fps, 1: ms, 2: mb, 3+: custom
			
			function millis() {

				return (new Date()).getTime();
			}
			
			function toRad(degree) {
			
				return Math.PI * 2 * degree / 360;
			}
		
			function onLoad() { 
                console.log(cdt2d);
				var canvasContainer = document.getElementById('myCanvasContainer');
                document.body.appendChild( stats.dom );
				var width = 800; 
				var height = 500;
				
				renderer = new THREE.WebGLRenderer(); 
				renderer.setSize(width, height);
				canvasContainer.appendChild(renderer.domElement);
				
				scene = new THREE.Scene();
                
				camera = new THREE.OrthographicCamera( width / - 2, width / 2, height / 2, height / - 2, 1, 1000 );
				camera.position.set(viewerPosition.x, viewerPosition.y, viewerPosition.z);
				camera.up = new THREE.Vector3(0, 1, 0);
				camera.lookAt(lookAt);
				
				vertexShader = document.getElementById('vertexShader').textContent;
				fragmentShader = document.getElementById('fragmentShader').textContent;
                
                metaballs = [
                    /*
                    new THREE.Vector3(-200.0, 0.0, 10.0),
                    new THREE.Vector3(-190.0, 0.0, 10.0),
                    new THREE.Vector3(-180.0, 0.0, 10.0),
                    new THREE.Vector3(-170.0, 0.0, 10.0),
                    new THREE.Vector3(-160.0, 0.0, 10.0),
                    new THREE.Vector3(-150.0, 0.0, 10.0),
                    */
                ];
                
                for (var i = metaballs.length; i < 20; i++) {
                    metaballs.push(new THREE.Vector3(-200.0+10.0*i, 0.0, 10.0+i));
                }
                
                var geometry = new THREE.PlaneBufferGeometry( 500, 500 );
                var material = new THREE.ShaderMaterial({
					uniforms: {
                        metaballs: new THREE.Uniform(metaballs)
                    },
					vertexShader: vertexShader,
					fragmentShader: fragmentShader,
                    side: THREE.DoubleSide
				});
                var plane = new THREE.Mesh( geometry, material );
                scene.add( plane );
                
                lines = new THREE.LineSegments( new THREE.Geometry, new THREE.LineBasicMaterial({color: 0xffffffff}) );
                scene.add(lines);
                
                triangles = new THREE.Mesh( new THREE.Geometry, new THREE.MeshBasicMaterial({color: 0xffffffff, wireframe: true}) );
                scene.add(triangles);
                
				draw();
				
                
				window.addEventListener('keydown', function(event) {
					if (event.keyCode == 38) { //Up
						smoothInterpolation = true;
                        interpolationStatusContainer.children[1].innerHTML = smoothInterpolation.toString();
					}
					if (event.keyCode == 40) { //Down
						smoothInterpolation = false;
                        interpolationStatusContainer.children[1].innerHTML = smoothInterpolation.toString();
					}
					if (event.keyCode == 37) { //Right
						interval--;
                        if (interval < 1)
                            interval = 1;
                        gridStatusContainer.children[1].innerHTML = interval.toString();
					}
					if (event.keyCode == 39) { //Left
                        interval++;
                        gridStatusContainer.children[1].innerHTML = interval.toString();
					}
					if (event.keyCode == 87) { //W
                        wireframe = !wireframe;
                        triangles.material.wireframe = wireframe;
                        wireframeStatusContainer.children[1].innerHTML = wireframe.toString();
					}
                    if (event.keyCode == 32) { //Space
                        paused = !paused;
					}
				}, false);
                
			}
			
			function draw() {
				requestAnimationFrame(draw);
                
                stats.begin();
				
                var dt = clock.getDelta();
                
                if (!paused) {
                    for (var i = 0; i < 20; i++) {
                        metaballs[i].applyAxisAngle(new THREE.Vector3(0.0, 0.0, 1.0),dt/(i+1));
                    }

                    var polygon = generatePolygon();
                    polygon.forEach(calculateData);

                    
                    scene.remove(lines);

                    lines = new THREE.Line( new THREE.Geometry, new THREE.LineBasicMaterial({color: 0xff00ff00}) );
                    lines.geometry.vertices = polygon;
                    lines.geometry.verticesNeedUpdate = true;
                    lines.position.z += 1;
                    scene.add(lines);
                    


                    scene.remove(triangles);

                    triangles = new THREE.Mesh( new THREE.Geometry, new THREE.MeshBasicMaterial({color: 0xffffffff, wireframe: wireframe}) );
                    triangles.geometry.vertices = polygon.slice(0);
                    var points = [];
                    
                    for (var i = 0; i < polygon.length; i++) {
                        points.push([polygon[i].x, polygon[i].y]);
                    }
                    for (var i = 0; i < metaballs.length; i++) {
                        metaball_loc = metaballs[i].clone();
                        metaball_loc.z = 0;
                        triangles.geometry.vertices.push(metaball_loc);
                        points.push([metaball_loc.x, metaball_loc.y])
                    }
                    
                    var edges = [];
                    for (var i = 0; i < polygon.length; i++) {
                        var j = (i + 1) % polygon.length;
                        edges.push([i, j]);
                    }
                    var faces = cdt2d(points, edges, {exterior: false});
                    
                    for (var i = 0; i < faces.length; i++) {
                        triangles.geometry.faces.push( new THREE.Face3(faces[i][0],faces[i][1],faces[i][2]) );
                    }
                    triangles.geometry.computeVertexNormals();
                    
                    scene.add(triangles);

                    dataContainer.children[1].innerHTML = polygon.length.toString();
                    dataContainer.children[4].innerHTML = triangles.geometry.faces.length.toString();
                }
                
				renderer.render(scene, camera);
                
                stats.end();
			}
            
            const UP = 0;
            const DOWN = 1;
            const LEFT = 2;
            const RIGHT = 3;
            
            function generatePolygon() {
                var start = metaballs[19].clone();
                start.z = 0;
                start.divideScalar(interval);
                start.ceil();
                start.multiplyScalar(interval);
                
                while (calculateValueAt(start) >= 1.0) {
                    start.add(new THREE.Vector3(0.0, interval));
                }
                
                var topLeft, topRight, bottomLeft, bottomRight;
                /*
                var topLeft = start.clone();
                var topRight = topLeft.clone().add(new THREE.Vector3(interval, 0));
                var bottomLeft = topLeft.clone().add(new THREE.Vector3(0.0, -interval));
                var bottomRight = topLeft.clone().add(new THREE.Vector3(interval, -interval));
                */
                topRight = addValueTo(start.clone());
                bottomRight = addValueTo(start.clone().add(new THREE.Vector3(0.0, -interval)));
                
                var prev = RIGHT;
                
                var vertices = [];

                passedStart = false;
                while (true) {
                    if (prev == RIGHT && topRight.equals(start)) {
                        if (passedStart) {
                            break;
                        }
                        passedStart = true;
                    }
                    
                    if (prev == UP) {
                        bottomLeft = topLeft;
                        bottomRight = topRight;
                        topLeft = addValueTo(bottomLeft.clone().add(new THREE.Vector3(0.0, interval)));
                        topRight = addValueTo(bottomRight.clone().add(new THREE.Vector3(0.0, interval)));
                        
                        var tl = topLeft.value >= 1.0;
                        var tr = topRight.value >= 1.0;
                        var bl = bottomLeft.value >= 1.0;
                        var br = bottomRight.value >= 1.0;
                        
                        if (tl && tr) {
                            prev = LEFT;
                            vertices.push(interpolateLocation(topLeft, bottomLeft));
                            continue;
                        }
                        if (!tl && tr) {
                            prev = UP;
                            vertices.push(nextVertex(prev, topLeft, topRight, bottomLeft, bottomRight));
                            continue;
                        }
                        if (!tl && !tr) {
                            prev = RIGHT;
                            vertices.push(nextVertex(prev, topLeft, topRight, bottomLeft, bottomRight));
                            continue;
                        }
                        if (tl && !tr) {
                            var middle = addValueTo(topLeft.clone().add(bottomRight).divideScalar(2.0));
                            if (middle.value >= 1.0) {
                                prev = LEFT;
                                vertices.push(nextVertex(prev, topLeft, topRight, bottomLeft, bottomRight));
                            } else {
                                prev = RIGHT;
                                vertices.push(nextVertex(prev, topLeft, topRight, bottomLeft, bottomRight));
                            }
                            continue;
                        }
                    }
                    
                    if (prev == DOWN) {
                        topLeft = bottomLeft;
                        topRight = bottomRight;
                        bottomLeft = addValueTo(topLeft.clone().add(new THREE.Vector3(0.0, -interval)));
                        bottomRight = addValueTo(topLeft.clone().add(new THREE.Vector3(interval, -interval)));
                        
                        var tl = topLeft.value >= 1.0;
                        var tr = topRight.value >= 1.0;
                        var bl = bottomLeft.value >= 1.0;
                        var br = bottomRight.value >= 1.0;
                        
                        if (bl && br) {
                            prev = RIGHT;
                            vertices.push(nextVertex(prev, topLeft, topRight, bottomLeft, bottomRight));
                            continue;
                        }
                        if (!bl && !br) {
                            prev = LEFT;
                            vertices.push(nextVertex(prev, topLeft, topRight, bottomLeft, bottomRight));
                            continue;
                        }
                        if (bl && !br) {
                            prev = DOWN;
                            vertices.push(nextVertex(prev, topLeft, topRight, bottomLeft, bottomRight));
                            continue;
                        }
                        if (!bl && br) {
                            var middle = addValueTo(topLeft.clone().add(bottomRight).divideScalar(2.0));
                            if (middle.value >= 1.0) {
                                prev = RIGHT;
                                vertices.push(nextVertex(prev, topLeft, topRight, bottomLeft, bottomRight));
                            } else {
                                prev = LEFT;
                                vertices.push(nextVertex(prev, topLeft, topRight, bottomLeft, bottomRight));
                            }
                            continue;
                        }
                    }
                    
                    if (prev == LEFT) {
                        topRight = topLeft;
                        bottomRight = bottomLeft;
                        topLeft = addValueTo(topRight.clone().add(new THREE.Vector3(-interval, 0.0)));
                        bottomLeft = addValueTo(bottomRight.clone().add(new THREE.Vector3(-interval, 0.0)));
                        
                        var tl = topLeft.value >= 1.0;
                        var tr = topRight.value >= 1.0;
                        var bl = bottomLeft.value >= 1.0;
                        var br = bottomRight.value >= 1.0;
                        
                        if (tl && bl) {
                            prev = DOWN;
                            vertices.push(nextVertex(prev, topLeft, topRight, bottomLeft, bottomRight));
                            continue;
                        }
                        if (!tl && !bl) {
                            prev = UP;
                            vertices.push(nextVertex(prev, topLeft, topRight, bottomLeft, bottomRight));
                            continue;
                        }
                        if (tl && !bl) {
                            prev = LEFT;
                            vertices.push(nextVertex(prev, topLeft, topRight, bottomLeft, bottomRight));
                            continue;
                        }
                        if (!tl && bl) {
                            var middle = addValueTo(topLeft.clone().add(bottomRight).divideScalar(2.0));
                            if (middle.value >= 1.0) {
                                prev = DOWN;
                                vertices.push(nextVertex(prev, topLeft, topRight, bottomLeft, bottomRight));
                            } else {
                                prev = UP;
                                vertices.push(nextVertex(prev, topLeft, topRight, bottomLeft, bottomRight));
                            }
                            continue;
                        }
                    }
                    
                    if (prev == RIGHT) {
                        topLeft = topRight;
                        bottomLeft = bottomRight;
                        topRight = addValueTo(topLeft.clone().add(new THREE.Vector3(interval, 0.0)));
                        bottomRight = addValueTo(bottomLeft.clone().add(new THREE.Vector3(interval, 0.0)));
                        
                        var tl = topLeft.value >= 1.0;
                        var tr = topRight.value >= 1.0;
                        var bl = bottomLeft.value >= 1.0;
                        var br = bottomRight.value >= 1.0;
                        
                        if (tr && br) {
                            prev = UP;
                            vertices.push(nextVertex(prev, topLeft, topRight, bottomLeft, bottomRight));
                            continue;
                        }
                        if (!tr && !br) {
                            prev = DOWN;
                            vertices.push(nextVertex(prev, topLeft, topRight, bottomLeft, bottomRight));
                            continue;
                        }
                        if (!tr && br) {
                            prev = RIGHT;
                            vertices.push(nextVertex(prev, topLeft, topRight, bottomLeft, bottomRight));
                            continue;
                        }
                        if (tr && !br) {
                            var middle = addValueTo(topLeft.clone().add(bottomRight).divideScalar(2.0));
                            if (middle.value >= 1.0) {
                                prev = UP;
                                vertices.push(nextVertex(prev, topLeft, topRight, bottomLeft, bottomRight));
                            } else {
                                prev = DOWN;
                                vertices.push(nextVertex(prev, topLeft, topRight, bottomLeft, bottomRight));
                            }
                            continue;
                        }
                    }
                }
                
                return vertices;
            }
            
            function nextVertex(dir, topLeft, topRight, bottomLeft, bottomRight) {
                if (dir == UP) {
                    return interpolateLocation(topLeft, topRight);
                }
                if (dir == DOWN) {
                    return interpolateLocation(bottomLeft, bottomRight);
                }
                if (dir == LEFT) {
                    return interpolateLocation(topLeft, bottomLeft);
                }
                if (dir == RIGHT) {
                    return interpolateLocation(topRight, bottomRight);
                }
            }
            
            function addValueTo(vec) {
                vec.value = calculateValueAt(vec);
                return vec;
            }
            
            function calculateValueAt(c) {
                var x = c.x;
                var y = c.y;
                var val = 0.0;
                for (var i = 0; i < metaballs.length; i++) {
                    metaball = metaballs[i];
                    addedVal = Math.pow(metaball.z, 2.0)/(Math.pow(metaball.x-x, 2.0)+Math.pow(metaball.y-y, 2.0));
                    if (isNaN(addedVal))
                        addedVal = 10000.0;
                    val += addedVal;
                }
                return val;
            }
            
            function calculateData(v) {
                var x = v.x;
                var y = v.y;
                
                var highestValue = 0;
                var closestMetaball_i = 0;
                for (var i = 0; i < metaballs.length; i++) {
                    metaball = metaballs[i];
                    distance = (Math.pow(metaball.x-x, 2.0)+Math.pow(metaball.y-y, 2.0));
                    addedVal = Math.pow(metaball.z, 2.0)/distance;
                    if (isNaN(addedVal))
                        addedVal = 10000.0;
                    
                    if (addedVal > highestValue) {
                        highestValue = addedVal;
                        closestMetaball_i = i;
                    }
                }
                
                v.closestMetaball = closestMetaball_i;
            }
            
            function interpolateLocation(loc1, loc2) {
                var val1 = loc1.value;
                var val2 = loc2.value;
                var a = (1-val2)/(val1-val2);
                if (!smoothInterpolation)
                    a = 0.5;
                return loc1.clone().multiplyScalar(a).add( loc2.clone().multiplyScalar(1-a) );
            }
			
		</script>

		<script id="vertexShader" type="x-shader/x-vertex">
			varying vec3 vertexPosition;
			void main() {
				vertexPosition = position;
				gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);
			}
		</script>
		<script id="fragmentShader" type="x-shader/x-fragment">
            uniform vec3 metaballs[20];
            varying vec3 vertexPosition;
            void main() {
                float dist = 0.0;
                for (int i = 0; i < 20; i++) {
                    dist += pow(metaballs[i].z, 2.0) / dot(metaballs[i].xy-vertexPosition.xy, metaballs[i].xy-vertexPosition.xy);
                }
                if (dist < 1.0) {
                    gl_FragColor = vec4(dist, 0.0, 0.0, 1.0);
                } else {
                    gl_FragColor = vec4(0.0, 0.0, dist-1.0, 1.0);
                }
			}
		</script>
	</head>
	<body onload="onLoad()">
		<div id="myCanvasContainer"></div>
        <div id="dataContainer">
			<span>Vertex count:</span>
			<span>0</span>
            <div></div>
            <span>Triangle count:</span>
			<span>0</span>
		</div>
		<div id="gridStatusContainer">
			<span>(left/right arrows) Grid interval:</span>
			<span>10</span>
		</div>
		<div id="interpolationStatusContainer">
			<span>(up/down arrows) Smooth interpolation:</span>
			<span>true</span>
		</div>
		<div id="wireframeStatusContainer">
			<span>(w) Wireframe:</span>
			<span>false</span>
		</div>
		<div>
			<span>(Space) Pause</span>
		</div>
	</body>
</html>