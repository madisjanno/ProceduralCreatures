<!DOCTYPE>
<html>
	<head>
		<title>Prototype</title>
		<script type="text/javascript" src="three.r87.js"></script>
        <script type="text/javascript" src="bundle.js"></script>
        <script type="text/javascript" src="http://rawgit.com/mrdoob/stats.js/master/build/stats.min.js"></script>
        <script type="text/javascript" src="dat.gui.min.js"></script>
		<script type="text/javascript">
		  
            // CAMERA
			var renderer, scene, camera;
			var lookAt = new THREE.Vector3(0.0, 0.0, 0.0);
			var viewerPosition = new THREE.Vector3(0.0, 0.0, 30.0);
            
            // GENERATION DATA
            var skeleton;
            var metaballs;
            var polygon;
            var texture;
            
            // GENERATED CREATURE
            var displayCreature = true;
            var creature;
            
            // GENERATED DATA DISPLAY
            var displaySkeleton = true;
            var skeletonhelper;
            
            var displayTexture = true;
            var textureDisplay;
            
            var displayMetaballs = true;
            var metaballDisplay;
            
            var displayOutline = false;
            var lines;
            
            // EYES
            var eyesArray = [];
            var eyeTexture = new THREE.TextureLoader().load( 'eye.png' );
            
            // BASE TEXTURES
            var woodTexture = new THREE.TextureLoader().load( 'wood.jpeg' );
            var iceTexture = new THREE.TextureLoader().load( 'ice.jpeg' );
            
            // OUTLINE GENERATION
            var interval = 5;
            var smoothInterpolation = true;
            
            // MESH GENERATION
            var internalVertices = true;
            var internalVertexDistance = 20;
            
            // SETTINGS
            var wireframe = false;
            var paused = true;
            
            // CLOCK
            var clock = new THREE.Clock();
            
            // INTERFACE
			var stats = new Stats();
			stats.showPanel( 1 ); // 0: fps, 1: ms, 2: mb, 3+: custom
            
            var grabbedBone = false;
            
            // PERFORMANCE TEST
            var numberOfTests = 100;
            var useTestingSkeleton = false;
            var testingSkeletonSegments = 1;
            var testingSkeletonLength = 60;
            var testingSkeletonThickness = 20;
            
            var skeletonTimes = [];
            var metaballTimes = [];
            var outlineTimes = [];
            var textureTimes = [];
            var meshTimes = [];
			
            // TIME
			function millis() {

				return (new Date()).getTime();
			}
			
            // UTILITY
			function toRad(degree) {
			
				return Math.PI * 2 * degree / 360;
			}
		
			function onLoad() { 
				var canvasContainer = document.getElementById('myCanvasContainer');
                document.body.appendChild( stats.dom );
				var width = 800;
				var height = 800;
				
				renderer = new THREE.WebGLRenderer(); 
				renderer.setSize(width, height);
				canvasContainer.appendChild(renderer.domElement);
				
				scene = new THREE.Scene();
                
				camera = new THREE.OrthographicCamera( width / - 2, width / 2, height / 2, height / - 2, 1, 1000 );
				camera.position.set(viewerPosition.x, viewerPosition.y, viewerPosition.z);
				camera.up = new THREE.Vector3(0, 1, 0);
				camera.lookAt(lookAt);
				
				vertexShader = document.getElementById('vertexShader').textContent;
				fragmentShader = document.getElementById('fragmentShader').textContent;
                
                createGUI();
                
                //--------------------------
                    generateCreature();    
                //--------------------------
                
				draw();
                
                renderer.domElement.addEventListener( 'mousedown', grabBone, false );
                renderer.domElement.addEventListener( 'mousemove', moveBone, false );
                renderer.domElement.addEventListener( 'mouseup', event => grabbedBone = false, false );
			}
            
            function grabBone(event) {
                var worldX = event.offsetX-400;
                var worldY = 800-event.offsetY-400;
                if (skeleton) {
                    for (var i = 0; i < skeleton.bones.length; i++) {
                        var bone = skeleton.bones[i];
                        var boneloc = bone.getWorldPosition();
                        if (boneloc.distanceTo(new THREE.Vector3(worldX, worldY, 0)) < Math.max(bone.thickness, 20) ) {
                            grabbedBone = bone;
                            return;
                        }
                    }
                }
            }
            
            function moveBone(event) {
                if (!grabbedBone)
                    return;
                
                var worldX = event.offsetX-400;
                var worldY = 800-event.offsetY-400;
                
                if (grabbedBone.parent.isBone) {
                    var grabbedBoneLoc = grabbedBone.getWorldPosition();
                    
                    var vecToBone = grabbedBoneLoc.clone().sub(grabbedBone.parent.getWorldPosition());
                    var vecToMouse = new THREE.Vector3(worldX, worldY, 0).sub(grabbedBone.parent.getWorldPosition());
                    
                    var angle = Math.atan2(vecToBone.x*vecToMouse.y-vecToBone.y*vecToMouse.x, vecToBone.x*vecToBone.x+vecToMouse.y*vecToMouse.y);
                    grabbedBone.parent.rotation.z += angle;
                } else {
                    grabbedBone.position.x = worldX;
                    grabbedBone.position.y = worldY;
                }
            }
            
            function createGUI() {
                var gui = new dat.GUI();
                
                var f1 = gui.addFolder('Outline generation');
                
                f1.add(this, 'interval');
                f1.add(this, 'smoothInterpolation');
                
                var f_mesh = gui.addFolder('Mesh generation');
                
                f_mesh.add(this, 'internalVertices');
                f_mesh.add(this, 'internalVertexDistance');
                
                var f2 = gui.addFolder('Display');
                
                var creatureToggle =  f2.add(this, 'displayCreature');
                creatureToggle.onFinishChange(value => creature.visible = value);
                
                var skeletonToggle = f2.add(this, 'displaySkeleton');
                skeletonToggle.onFinishChange(value => skeletonhelper.visible = value);
                
                var textureToggle = f2.add(this, 'displayTexture');
                textureToggle.onFinishChange(value => textureDisplay.visible = value);
                
                var metaballToggle = f2.add(this, 'displayMetaballs');
                metaballToggle.onFinishChange(value => metaballDisplay.visible = value);
                
                var outlineToggle = f2.add(this, 'displayOutline');
                outlineToggle.onFinishChange(value => lines.visible = value);
                
                var f3 = gui.addFolder('Performance Test');
                f3.add(this, 'useTestingSkeleton');
                    
                var f4 = f3.addFolder('Testing Skeleton');
                f4.add(this, 'testingSkeletonSegments').name("segments");
                f4.add(this, 'testingSkeletonLength').name("length");
                f4.add(this, 'testingSkeletonThickness').name("thickness");
                
                f3.add(this, 'numberOfTests');
                f3.add(this, 'performanceTest');
                
                
                var wireToggle = gui.add(this, 'wireframe');
                wireToggle.onFinishChange(value => creature.material.wireframe = value);
                
                gui.add(this, 'paused');
                gui.add(this, 'generateCreature');
            }
			
			function draw() {
				requestAnimationFrame(draw);
                
                stats.begin();
				
                var dt = clock.getDelta();
                
                if (!paused) {
                    
                    for (var i = 1; i < skeleton.bones.length; i++) {
                        if (!skeleton.bones[i].doNotAnimate)
                            skeleton.bones[i].rotation.z = Math.sin(clock.getElapsedTime()*(i/0.23+1)/10.0);
                    }
                    for (var i = 0; i < eyesArray.length; i++) {
                        var val = Math.cos(clock.getElapsedTime()*3+i*50);
                        if (val < 0.0)
                            val = 1.0;
                        else
                            val = 1-val;
                        //eyesArray[i].scale.y = val * val * (3 - 2 * val) +0.05;
                    }
                }
                
				renderer.render(scene, camera);
                
                stats.end();
			}
            
            function performanceTest() {
                skeletonTimes = [];
                metaballTimes = [];
                outlineTimes = [];
                textureTimes = [];
                meshTimes = [];
                for (var i = 0; i < numberOfTests; i++) {
                    generateCreature();
                }
                function calculateAverage (arr) {
                    var sum = 0;
                    for (var i = 0; i < numberOfTests; i++) {
                        sum += arr[i];
                    }
                    return sum / numberOfTests;
                }

                console.log("skeleton",calculateAverage(skeletonTimes)*1000);
                console.log("metaball",calculateAverage(metaballTimes)*1000);
                console.log("outline",calculateAverage(outlineTimes)*1000);
                console.log("texture",calculateAverage(textureTimes)*1000);
                console.log("mesh",calculateAverage(meshTimes)*1000);
            }
            
            function generateCreature() {
                scene.remove(creature);
                scene.remove(lines);
                scene.remove(skeletonhelper);
                scene.remove(metaballDisplay);
                scene.remove(textureDisplay);
                
                var timer = new THREE.Clock();
                timer.getElapsedTime();
                
                // SKELETON
                console.log("generating skeleton");
                skeleton = generateSkeleton();
                skeletonTimes.push(timer.getElapsedTime());
                
                // METABALLS
                console.log("generating metaballs");
                metaballs = [];
                generateMetaballs(metaballs, skeleton.bones[0]);
                
                metaballTimes.push(timer.getElapsedTime());
                
                // OUTLINE
                console.log("generating polygon");
                polygon = generatePolygon(metaballs);
                outlineTimes.push(timer.getElapsedTime());
                
                lines = new THREE.Line( new THREE.Geometry, new THREE.LineBasicMaterial({color: 0xff00ff00}) );
                lines.geometry.vertices = polygon;
                lines.geometry.verticesNeedUpdate = true;
                lines.position.z += 1;
                lines.position.x += 100;
                
                scene.add(lines);
                lines.visible = displayOutline;
                
                // TEXTURE
                console.log("generating texture");
                // bounding box of mesh
                var lowestX = polygon[0].x, lowestY = polygon[0].y, highestX = polygon[0].x, highestY = polygon[0].y;
                for (var i = 0; i < polygon.length; i++) {
                    lowestX = Math.min(lowestX, polygon[i].x)
                    lowestY = Math.min(lowestY, polygon[i].y)
                    highestX = Math.max(highestX, polygon[i].x)
                    highestY = Math.max(highestY, polygon[i].y)
                }
                texture = generateTexture(metaballs, [lowestX, lowestY, highestX-lowestX, highestY-lowestY]);
                textureTimes.push(timer.getElapsedTime());
                
                // MESH
                console.log("generating mesh");
                creature = generateMesh(texture, polygon, metaballs, skeleton);
                meshTimes.push(timer.getElapsedTime());
                
                skeletonhelper = new THREE.SkeletonHelper( creature );
                scene.add(creature);
                creature.visible = displayCreature;
                
                scene.add(skeletonhelper);
                skeletonhelper.visible = displaySkeleton;
                
                // METABALL DISPLAY
                var geometry = new THREE.PlaneBufferGeometry( 700, 700 );
                var material = new THREE.ShaderMaterial({
					uniforms: {
                        metaballs: new THREE.Uniform(metaballs)
                    },
					vertexShader: vertexShader,
					fragmentShader: fragmentShader.replace("METABALL_COUNT", metaballs.length),
                    side: THREE.DoubleSide
				});
                metaballDisplay = new THREE.Mesh( geometry, material );
                metaballDisplay.position.z = -1;
                metaballDisplay.position.x += 100;
                scene.add( metaballDisplay );
                metaballDisplay.visible = displayMetaballs;
                
                // TEXTURE DISPLAY
                var geometry = new THREE.PlaneBufferGeometry( 256, 256 );
                var material = new THREE.MeshBasicMaterial({map: texture});
                textureDisplay = new THREE.Mesh( geometry, material );
                textureDisplay.position.x -= 400-128;
                textureDisplay.position.y += 250-128;
                scene.add( textureDisplay );
                textureDisplay.visible = displayTexture;
            }
            
            function generateSkeleton() {
                if (useTestingSkeleton) {
                    var bone = new THREE.Bone();
                    bone.thickness = 0;
                    var bones = [bone];
                    
                    for (var i = 0; i < testingSkeletonSegments; i++) {
                        bone = new THREE.Bone();
                        bone.thickness = testingSkeletonThickness;
                        bone.position.x = testingSkeletonLength;
                        
                        bones[bones.length-1].add(bone);
                        bones.push(bone);
                    }
                    return new THREE.Skeleton(bones);
                }
                
                // -- DEBUG
                /*
                bone = new THREE.Bone();
                    bone.thickness = 20;
                
                var b2 = new THREE.Bone();
                    b2.thickness = 10;
                    bone.add(b2);
                    b2.position.y = 70;
                    b2.multiplier = 1.0;
                    b2.color = new THREE.Vector3(1.0, 0.0, 0.0);
                
                var b3 = new THREE.Bone();
                    b3.thickness = 5;
                    bone.add(b3);
                    b3.position.x = 40;
                    b3.color = new THREE.Vector3(0.0, 0.0, 1.0);
                    b3.multiplier = 1.0;
                
                var b4 = new THREE.Bone();
                    b4.thickness = 25;
                    b3.add(b4);
                    b4.position.x = 80;
                    b4.color = new THREE.Vector3(0.0, 0.0, 1.0);
                    b4.multiplier = 1.0;
                
                var b5 = new THREE.Bone();
                    b5.thickness = 5;
                    bone.add(b5);
                    b5.position.x = -40;
                    b5.color = new THREE.Vector3(0.0, 0.0, 1.0);
                    b5.multiplier = 1.6;
                
                var b6 = new THREE.Bone();
                    b6.thickness = 25;
                    b5.add(b6);
                    b6.position.x = -80;
                    b6.color = new THREE.Vector3(0.0, 0.0, 1.0);
                    b6.multiplier = 1.6;
                
                
                var skeleton = new THREE.Skeleton([bone, b2, b3, b4, b5, b6]);
                return skeleton;
                */
                /*
                var s = [];
                bone = new THREE.Bone();
                bone.position.x = -100;
                bone.thickness = 0;
                s.push(bone);
                
                for (var i = 0; i <= 6; i++) {
                    var bone = new THREE.Bone();
                    bone.thickness = 10;
                    bone.position.x = 700;
                    bone.multiplier = 1.0+i/6*0.6;
                    
                    s[s.length-1].add(bone);
                    s.push(bone);
                    
                    bone = new THREE.Bone();
                    bone.thickness = 0;
                    bone.position.y = 50;
                    
                    s[s.length-2].add(bone);
                    s.push(bone);
                }
                
                var skeleton = new THREE.Skeleton(s);
                return skeleton;
                */
                // -- DEBUG
                
                
                
                // SPINE
                var spineSegments = Math.round(3+Math.random()*3);
                
                var skeleton = [];
                var spine = [];
                var rootBone = new THREE.Bone();
                rootBone.thickness = 0;
                spine.push(rootBone);
                
                for (var i = 1; i < spineSegments; i++) {
                    var spineSegment = new THREE.Bone();
                    
                    spineSegment.thickness = 10+Math.random()*30;
                    spineSegment.position.y = 50+Math.random()*50;
                    var a = Math.random();
                    spineSegment.texture_weights = new THREE.Vector4(a, 1.0-a, 0.0, 0.0);
                    spineSegment.color = new THREE.Vector3(Math.random(), Math.random(), Math.random());
                    spineSegment.multiplier = 1+Math.random()*0.6;
                    
                    spine[i-1].add(spineSegment);
                    spine.push(spineSegment);
                }
                skeleton.push(...spine);
                skeleton[skeleton.length-1].doNotAnimate = true;
                
                // EYES
                var eyes = Math.floor(1+Math.random()*7);
                var eyeSize = skeleton[skeleton.length-1].thickness*(0.5+Math.random()*0.5);
                var eyeDistance = skeleton[skeleton.length-1].thickness - eyeSize/2;
                    
                var eyeMesh = new THREE.Mesh( new THREE.PlaneGeometry( eyeSize, eyeSize ), new THREE.MeshBasicMaterial({map: eyeTexture, side: THREE.DoubleSide, transparent:true, opacity: 0.8}) );
                
                for (var i = 0; i < eyes; i++) {
                    var angle = Math.PI/eyes*i*2.0;
                    if (eyes % 2 == 1) {
                        angle += Math.PI*0.5;
                    }
                    var x = Math.cos(angle)*eyeDistance;
                    var y = Math.sin(angle)*eyeDistance;
                    
                    var eye = eyeMesh.clone();
                    eye.position.x = x;
                    eye.position.y = y;
                    eye.position.z = 1;
                    skeleton[skeleton.length-1].add(eye);
                    eyesArray.push(eye);
                }
                
                
                // LIMBS
                for (var i = 0; i < spineSegments; i++) {
                    if (Math.random() > 0.5) {
                        var limbSegments = Math.round(2+Math.random()*2);
                        
                        var limbSegmentLengths = [];
                        var limbSegmentThicknesses = [];
                        var limbSegmentMultipliers = [];
                        
                        for (var j = 0; j < limbSegments; j++) {
                            limbSegmentLengths.push(50+Math.random()*30);
                            limbSegmentThicknesses.push(5+Math.random()*10);
                            limbSegmentMultipliers.push(1+Math.random()*0.6);
                        }
                        limbSegmentThicknesses[0] = 5;
                        
                        for (var dir = -1; dir < 2; dir+=2) {
                            var limb = [];
                            
                            var limbJoint = new THREE.Bone();
                            if (i > 0)
                                limbJoint.position.x = dir*spine[i].thickness;
                            else
                                limbJoint.position.x = dir*spine[i+1].thickness;
                            limbJoint.thickness = limbSegmentThicknesses[0];
                            limbJoint.color = new THREE.Vector3(Math.random(), Math.random(), Math.random());
                            limb.push(limbJoint);
                            spine[i].add(limbJoint);
                            
                            for (var j = 1; j < limbSegments; j++) {
                                var limbSegment = new THREE.Bone();

                                limbSegment.thickness = limbSegmentThicknesses[j];
                                limbSegment.position.x = dir*limbSegmentLengths[j];
                                limbSegment.color = new THREE.Vector3(Math.random(), Math.random(), Math.random());
                                limbSegment.multiplier = limbSegmentMultipliers[j];

                                limb[j-1].add(limbSegment);
                                limb.push(limbSegment);
                            }
                            
                            skeleton.push(...limb);
                        }
                        
                    }
                }
                
                return new THREE.Skeleton(skeleton);
            }
            
            function generateMetaballs(metaballs, bone, parent) {
                if (parent !== undefined && bone.thickness > 0.0) {
                    
                    var boneLocation = bone.getWorldPosition();
                    var parentLocation = parent.getWorldPosition();
                    
                    var subballs = 1;
                    boneLocation.z = bone.thickness / Math.sqrt(subballs);
                    parentLocation.z = bone.thickness / Math.sqrt(subballs);
                    

                    var mult = 1.6;
                    if (bone.multiplier) {
                        mult = bone.multiplier;
                    }
                    var thicknessMult = (mult)*Math.sqrt(1/(4*Math.log(mult)+1));
                    thicknessMult = mult/Math.sqrt(2*Math.log(mult*mult)+1);
                    
                    subballs = Math.ceil(boneLocation.distanceTo(parentLocation)/(bone.thickness*2.97)*mult);
                    
                    
                    boneLocation.z = bone.thickness*thicknessMult;
                    parentLocation.z = bone.thickness*thicknessMult;
                    
                    for (var i = 0; i <= subballs; i++) {
                        
                        var alpha = i/subballs;
                        var ball = boneLocation.clone().lerp(parentLocation, alpha);
                        ball.boneID = skeleton.bones.indexOf(parent);
                        //if (alpha < 0.1)
                        //    ball.boneID = skeleton.bones.indexOf(bone);
                        
                        if (bone.color) {
                            if (parent.color) {
                                ball.color = bone.color.clone().lerp(parent.color, alpha);
                            } else {
                                ball.color = bone.color;
                            }
                        }
                        if (bone.texture_weights) {
                            ball.texture_weights = bone.texture_weights;
                        }
                        
                        metaballs.push(ball);
                    }
                }
                
                bone.children.forEach(function(child) {
                    generateMetaballs(metaballs, child, bone);
                });
            }
            
            const UP = 0;
            const DOWN = 1;
            const LEFT = 2;
            const RIGHT = 3;
            
            function generatePolygon(metaballs) {
                var start = metaballs[0];
                for (var i = 1; i < metaballs.length; i++) {
                    if (metaballs[i].y > start.y) {
                        start = metaballs[i];
                    }
                }
                start = start.clone();
                
                start.z = 0;
                
                var counter = 0;
                while (calculateValueAt(start, metaballs) >= 1.0) {
                    //console.log("crawling in my skiiin", start, calculateValueAt(start, metaballs));
                    start.add(new THREE.Vector3(0.0, interval));
                    counter++;
                    if (counter > 100)
                        return;
                }
                //console.log("crawling complete", start, calculateValueAt(start, metaballs));
                
                var topLeft, topRight, bottomLeft, bottomRight;
                /*
                var topLeft = start.clone();
                var topRight = topLeft.clone().add(new THREE.Vector3(interval, 0));
                var bottomLeft = topLeft.clone().add(new THREE.Vector3(0.0, -interval));
                var bottomRight = topLeft.clone().add(new THREE.Vector3(interval, -interval));
                */
                topRight = addValueTo(start.clone(), metaballs);
                bottomRight = addValueTo(start.clone().add(new THREE.Vector3(0.0, -interval)), metaballs);
                
                var prev = RIGHT;
                
                var vertices = [];

                passedStart = false;
                
                var x = -1;
                var y = 0;
                
                var counter = 0;
                while (counter < 20000) {
                    counter++;
                    if (prev == RIGHT) {x++;}
                    if (prev == LEFT) {x--;}
                    if (prev == UP) {y++;}
                    if (prev == DOWN) {y--}
                    
                    if (prev == RIGHT && x == 0 && y == 0) {
                        if (passedStart) {
                            break;
                        }
                        passedStart = true;
                    }
                    
                    if (prev == UP) {
                        bottomLeft = topLeft;
                        bottomRight = topRight;
                        topLeft = addValueTo(bottomLeft.clone().add(new THREE.Vector3(0.0, interval)), metaballs);
                        topRight = addValueTo(bottomRight.clone().add(new THREE.Vector3(0.0, interval)), metaballs);
                        
                        var tl = topLeft.value >= 1.0;
                        var tr = topRight.value >= 1.0;
                        var bl = bottomLeft.value >= 1.0;
                        var br = bottomRight.value >= 1.0;
                        
                        if (tl && tr) {
                            prev = LEFT;
                            vertices.push(interpolateLocation(topLeft, bottomLeft));
                            continue;
                        }
                        if (!tl && tr) {
                            prev = UP;
                            vertices.push(nextVertex(prev, topLeft, topRight, bottomLeft, bottomRight));
                            continue;
                        }
                        if (!tl && !tr) {
                            prev = RIGHT;
                            vertices.push(nextVertex(prev, topLeft, topRight, bottomLeft, bottomRight));
                            continue;
                        }
                        if (tl && !tr) {
                            var middle = addValueTo(topLeft.clone().add(bottomRight).divideScalar(2.0), metaballs);
                            if (middle.value >= 1.0) {
                                prev = LEFT;
                                vertices.push(nextVertex(prev, topLeft, topRight, bottomLeft, bottomRight));
                            } else {
                                prev = RIGHT;
                                vertices.push(nextVertex(prev, topLeft, topRight, bottomLeft, bottomRight));
                            }
                            continue;
                        }
                    }
                    
                    if (prev == DOWN) {
                        topLeft = bottomLeft;
                        topRight = bottomRight;
                        bottomLeft = addValueTo(topLeft.clone().add(new THREE.Vector3(0.0, -interval)), metaballs);
                        bottomRight = addValueTo(topLeft.clone().add(new THREE.Vector3(interval, -interval)), metaballs);
                        
                        var tl = topLeft.value >= 1.0;
                        var tr = topRight.value >= 1.0;
                        var bl = bottomLeft.value >= 1.0;
                        var br = bottomRight.value >= 1.0;
                        
                        if (bl && br) {
                            prev = RIGHT;
                            vertices.push(nextVertex(prev, topLeft, topRight, bottomLeft, bottomRight));
                            continue;
                        }
                        if (!bl && !br) {
                            prev = LEFT;
                            vertices.push(nextVertex(prev, topLeft, topRight, bottomLeft, bottomRight));
                            continue;
                        }
                        if (bl && !br) {
                            prev = DOWN;
                            vertices.push(nextVertex(prev, topLeft, topRight, bottomLeft, bottomRight));
                            continue;
                        }
                        if (!bl && br) {
                            var middle = addValueTo(topLeft.clone().add(bottomRight).divideScalar(2.0), metaballs);
                            if (middle.value >= 1.0) {
                                prev = RIGHT;
                                vertices.push(nextVertex(prev, topLeft, topRight, bottomLeft, bottomRight));
                            } else {
                                prev = LEFT;
                                vertices.push(nextVertex(prev, topLeft, topRight, bottomLeft, bottomRight));
                            }
                            continue;
                        }
                    }
                    
                    if (prev == LEFT) {
                        topRight = topLeft;
                        bottomRight = bottomLeft;
                        topLeft = addValueTo(topRight.clone().add(new THREE.Vector3(-interval, 0.0)), metaballs);
                        bottomLeft = addValueTo(bottomRight.clone().add(new THREE.Vector3(-interval, 0.0)), metaballs);
                        
                        var tl = topLeft.value >= 1.0;
                        var tr = topRight.value >= 1.0;
                        var bl = bottomLeft.value >= 1.0;
                        var br = bottomRight.value >= 1.0;
                        
                        if (tl && bl) {
                            prev = DOWN;
                            vertices.push(nextVertex(prev, topLeft, topRight, bottomLeft, bottomRight));
                            continue;
                        }
                        if (!tl && !bl) {
                            prev = UP;
                            vertices.push(nextVertex(prev, topLeft, topRight, bottomLeft, bottomRight));
                            continue;
                        }
                        if (tl && !bl) {
                            prev = LEFT;
                            vertices.push(nextVertex(prev, topLeft, topRight, bottomLeft, bottomRight));
                            continue;
                        }
                        if (!tl && bl) {
                            var middle = addValueTo(topLeft.clone().add(bottomRight).divideScalar(2.0), metaballs);
                            if (middle.value >= 1.0) {
                                prev = DOWN;
                                vertices.push(nextVertex(prev, topLeft, topRight, bottomLeft, bottomRight));
                            } else {
                                prev = UP;
                                vertices.push(nextVertex(prev, topLeft, topRight, bottomLeft, bottomRight));
                            }
                            continue;
                        }
                    }
                    
                    if (prev == RIGHT) {
                        topLeft = topRight;
                        bottomLeft = bottomRight;
                        topRight = addValueTo(topLeft.clone().add(new THREE.Vector3(interval, 0.0)), metaballs);
                        bottomRight = addValueTo(bottomLeft.clone().add(new THREE.Vector3(interval, 0.0)), metaballs);
                        
                        var tl = topLeft.value >= 1.0;
                        var tr = topRight.value >= 1.0;
                        var bl = bottomLeft.value >= 1.0;
                        var br = bottomRight.value >= 1.0;
                        
                        if (tr && br) {
                            prev = UP;
                            vertices.push(nextVertex(prev, topLeft, topRight, bottomLeft, bottomRight));
                            continue;
                        }
                        if (!tr && !br) {
                            prev = DOWN;
                            vertices.push(nextVertex(prev, topLeft, topRight, bottomLeft, bottomRight));
                            continue;
                        }
                        if (!tr && br) {
                            prev = RIGHT;
                            vertices.push(nextVertex(prev, topLeft, topRight, bottomLeft, bottomRight));
                            continue;
                        }
                        if (tr && !br) {
                            var middle = addValueTo(topLeft.clone().add(bottomRight).divideScalar(2.0), metaballs);
                            if (middle.value >= 1.0) {
                                prev = UP;
                                vertices.push(nextVertex(prev, topLeft, topRight, bottomLeft, bottomRight));
                            } else {
                                prev = DOWN;
                                vertices.push(nextVertex(prev, topLeft, topRight, bottomLeft, bottomRight));
                            }
                            continue;
                        }
                    }
                }
                
                return vertices;
            }
            
            function generateMesh(texture, polygon, metaballs, skeleton) {
                
                var triangles = new THREE.SkinnedMesh( new THREE.Geometry, new THREE.MeshBasicMaterial({color: 0xffffffff, wireframe: wireframe, skinning:true, map: texture}) );
                triangles.geometry.vertices = polygon.slice(0);

                // vertices
                var points = [];

                for (var i = 0; i < polygon.length; i++) {
                    points.push([polygon[i].x, polygon[i].y]);
                }
                
                /*
                for (var i = 0; i < metaballs.length; i++) {
                    metaball_loc = metaballs[i].clone();
                    metaball_loc.z = 0;
                    
                    metaball_loc.x += Math.random();
                    metaball_loc.y += Math.random();

                    triangles.geometry.vertices.push(metaball_loc);
                    points.push([metaball_loc.x, metaball_loc.y])

                }
                */
                
                // area covered by mesh
                var lowestX = polygon[0].x, lowestY = polygon[0].y, highestX = polygon[0].x, highestY = polygon[0].y;
                for (var i = 0; i < polygon.length; i++) {
                    lowestX = Math.min(lowestX, polygon[i].x)
                    lowestY = Math.min(lowestY, polygon[i].y)
                    highestX = Math.max(highestX, polygon[i].x)
                    highestY = Math.max(highestY, polygon[i].y)
                }
                
                console.log(points.length);
                // adds points in uniform grid to fill out interior
                if (internalVertices) {
                    var offset = highestY-lowestY;
                    for (var x = lowestX+0.01; x < highestX+offset; x+=internalVertexDistance+0.1711) {
                        for (var y = lowestY+0.01; y < highestY; y+=internalVertexDistance+0.1711) {
                            var skew = (y-lowestY)/2;
                            if (polygonContainsVertex({x: x-skew, y: y}, polygon)) {
                                triangles.geometry.vertices.push(new THREE.Vector3(x-skew, y, 0));
                                points.push([x-skew, y])
                            }
                            //triangles.geometry.vertices.push(new THREE.Vector3(x-skew, y, 0));
                            //points.push([x-skew, y])
                        }
                    }
                }
                console.log(points.length);
                
                var edges = [];
                for (var i = 0; i < polygon.length; i++) {
                    var j = (i + 1) % polygon.length;
                    edges.push([i, j]);
                }
                
                // faces
                var faces = cdt2d(points, edges, {exterior: false});
                triangles.geometry.faceVertexUvs = [[]];
                
                width = highestX - lowestX;
                height = highestY - lowestY;
                function mapUV(vertexI) {
                    var vertex = triangles.geometry.vertices[vertexI];
                    return new THREE.Vector2( (vertex.x-lowestX)/width, (vertex.y-lowestY)/height );
                }
                
                for (var i = 0; i < faces.length; i++) {
                    triangles.geometry.faces.push( new THREE.Face3(faces[i][0],faces[i][1],faces[i][2]) );
                    triangles.geometry.faceVertexUvs[0].push([mapUV(faces[i][0]),mapUV(faces[i][1]),mapUV(faces[i][2])]);
                }
                
                triangles.geometry.computeVertexNormals();
                
                // skinning and z
                triangles.add(skeleton.bones[0]);
                for (var i = 0; i < triangles.geometry.vertices.length; i++) {
                    var data = calculateSkinningData(triangles.geometry.vertices[i], metaballs, skeleton);
                    //console.log(data);
                    triangles.geometry.skinIndices.push( data[0] );
                    triangles.geometry.skinWeights.push( data[1] );
                    
                    triangles.geometry.vertices[i].z = (triangles.geometry.vertices[i].y-lowestY)/height;
                }
                triangles.bind( skeleton );
                
                return triangles;
            }
            
            function polygonContainsVertex(vertex, polygon) {
                var i = 0, j = polygon.length - 1;
                var contains = false;
                
                for (var i = 0, j = 1; i < polygon.length; i++) {
                    j = (i+1) % polygon.length;
                    var a = polygon[i];
                    var b = polygon[j];
                    if (a.y < b.y) {
                        a = polygon[j];
                        b = polygon[i];
                    }
                    if (vertex.y < a.y && vertex.y >= b.y) {
                        if (vertex.x < (b.x-a.x)/(b.y-a.y)*(vertex.y-a.y)+a.x )
                            contains = !contains;
                    }
                }
                return contains;
            }
            
            function nextVertex(dir, topLeft, topRight, bottomLeft, bottomRight) {
                if (dir == UP) {
                    return interpolateLocation(topLeft, topRight);
                }
                if (dir == DOWN) {
                    return interpolateLocation(bottomLeft, bottomRight);
                }
                if (dir == LEFT) {
                    return interpolateLocation(topLeft, bottomLeft);
                }
                if (dir == RIGHT) {
                    return interpolateLocation(topRight, bottomRight);
                }
            }
            
            function addValueTo(vec, metaballs) {
                vec.value = calculateValueAt(vec, metaballs);
                return vec;
            }
            
            function calculateMetaballValue(x, y, metaball) {
                var distance = Math.pow(metaball.x-x, 2.0)+Math.pow(metaball.y-y, 2.0);
                //var blobbyness = -0.25;
                var blobbyness = -0.5;
                return 1.0*Math.exp(blobbyness*distance/(metaball.z*metaball.z)-blobbyness);
                
            }
            
            function calculateValueAt(c, metaballs) {
                var x = c.x;
                var y = c.y;
                var val = 0.0;
                for (var i = 0; i < metaballs.length; i++) {
                    var metaball = metaballs[i];
                    //addedVal = Math.pow(metaball.z, 2.0)/(Math.pow(metaball.x-x, 2.0)+Math.pow(metaball.y-y, 2.0));
                    var addedVal = calculateMetaballValue(x, y, metaball);
                    if (!isFinite(addedVal)) {
                        //console.log(addedVal);
                        addedVal = 10000.0;
                    }
                    val += addedVal;
                }
                return val;
            }
            
            function calculateSkinningData(v, metaballs, skeleton) {
                var x = v.x;
                var y = v.y;
                
                boneValues = []
                for (var i = 0; i < skeleton.bones.length; i++) [boneValues.push({id:i,value:0})]
                
                for (var i = 0; i < metaballs.length; i++) {
                    var metaball = metaballs[i];
                    //addedVal = Math.pow(Math.pow(metaball.z, 2.0)/distance, 2.0);
                    var addedVal = calculateMetaballValue(x, y, metaball);
                    if (!isFinite(addedVal))
                        addedVal = 10000.0;
                    
                    boneValues[metaball.boneID].value += addedVal;
                }
                
                boneValues.sort(function(a, b){return b.value - a.value});
                while (boneValues.length < 4) {
                    boneValues.push({id:0,value:0});
                }
                
                boneIndices = new THREE.Vector4( 
                        boneValues[0].id,
                        boneValues[1].id, 
                        boneValues[2].id, 
                        boneValues[3].id
                    );
                
                boneWeights = new THREE.Vector4( 
                        boneValues[0].value,
                        boneValues[1].value, 
                        boneValues[2].value, 
                        boneValues[3].value
                    );
                
                boneWeights.divideScalar(boneWeights.lengthManhattan());
                
                return [boneIndices, boneWeights];
                
            }
            
            function interpolateLocation(loc1, loc2) {
                var val1 = loc1.value;
                var val2 = loc2.value;
                var a = (1-val2)/(val1-val2);
                if (!smoothInterpolation)
                    a = 0.5;
                //return loc1.clone().multiplyScalar(a).add( loc2.clone().multiplyScalar(1-a) );
                if (isNaN(loc1.clone().lerp(loc2, 1-a).x)) {
                    console.log(loc1, loc2);
                }
                
                return (loc1.clone().lerp(loc2, 1-a));
            }
            
            function generateTexture(metaballs, bounds) {
                // camera setup
                var texRenderTarget = new THREE.WebGLRenderTarget(256, 256);
                var texScene = new THREE.Scene();
                var texCamera = new THREE.OrthographicCamera( 256 / - 2, 256 / 2, 256 / 2, 256 / - 2, 1, 1000 );
				texCamera.position.set(0, 0, 30);
                
                // shader uniforms and metaball data
                var colors = [];
                var texture_weights = [];
                for (var i = 0; i < metaballs.length; i++) {
                    if (metaballs[i].color) {
                        colors.push(metaballs[i].color);
                    } else {
                        colors.push(new THREE.Vector3(1.0,1.0,1.0));
                    }
                    
                    if (metaballs[i].texture_weights) {
                        texture_weights.push(metaballs[i].texture_weights);
                    } else {
                        texture_weights.push(new THREE.Vector4(1.0,0.0,0.0,0.0));
                    }
                }
                
                
                // shader setup
                var geometry = new THREE.PlaneBufferGeometry( 256, 256 );
                var material = new THREE.ShaderMaterial({
					uniforms: {
                        metaballs: new THREE.Uniform(metaballs),
                        metaball_colors: new THREE.Uniform(colors),
                        metaball_texture_weights: new THREE.Uniform(texture_weights),
                        bounds: new THREE.Uniform(new THREE.Vector4(bounds[0], bounds[1], bounds[2], bounds[3])),
                        tex_0: new THREE.Uniform(woodTexture),
                        tex_1: new THREE.Uniform(iceTexture)
                    },
					vertexShader: vertexShader,
					fragmentShader: document.getElementById('textureFragmentShader').textContent.replace("METABALL_COUNT", metaballs.length),
                    side: THREE.DoubleSide
				});
                var plane = new THREE.Mesh( geometry, material );
                texScene.add(plane);
                
                renderer.render(texScene, texCamera, texRenderTarget);
                
                return texRenderTarget.texture;
            }
			
		</script>

		<script id="vertexShader" type="x-shader/x-vertex">
			varying vec3 vertexPosition;
            varying vec2 frag_uv;
			void main() {
				vertexPosition = position;
                frag_uv = uv;
				gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);
			}
		</script>
		<script id="fragmentShader" type="x-shader/x-fragment">
            #define METABALL_C METABALL_COUNT
        
            uniform vec3 metaballs[METABALL_C];
            varying vec3 vertexPosition;
            void main() {
                
                float dist = 0.0;
                float insideBall = 0.0;
                for (int i = 0; i < METABALL_C; i++) {
                    //dist += pow(metaballs[i].z, 2.0) / dot(metaballs[i].xy-vertexPosition.xy, metaballs[i].xy-vertexPosition.xy);
                    
                    float distance = dot(metaballs[i].xy-vertexPosition.xy, metaballs[i].xy-vertexPosition.xy);
                    float blobbyness = -0.5;
                    float extraVal = 1.0*exp(blobbyness*distance/(metaballs[i].z*metaballs[i].z)-blobbyness);
                    dist += extraVal;
                    insideBall = extraVal > 1.0 ? 1.0 : insideBall;
                    
                    
                }
                if (dist < 1.0) {
                    gl_FragColor = vec4(dist, 0.0, 0.0, 1.0);
                } else {
                    gl_FragColor = vec4(0.0, 0.0, dist-1.0, 1.0);
                }
                /*
                if (insideBall > 0.5) {
                    gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);
                }
                */
                /*
                float dist = 0.0;
                for (int i = 0; i < METABALL_COUNT; i++) {
                    dist = pow(metaballs[i].z, 2.0) / dot(metaballs[i].xy-vertexPosition.xy, metaballs[i].xy-vertexPosition.xy) > 1.0 ? 1.0 : dist;
                }
                if (dist < 1.0) {
                    gl_FragColor = vec4(dist, 0.0, 0.0, 1.0);
                } else {
                    gl_FragColor = vec4(0.0, 0.0, dist, 1.0);
                }*/
			}
		</script>
		<script id="textureFragmentShader" type="x-shader/x-fragment">
            #define METABALL_C METABALL_COUNT
        
            uniform vec3 metaballs[METABALL_C];
            uniform vec3 metaball_colors[METABALL_C];
            uniform vec4 metaball_texture_weights[METABALL_C];

            uniform sampler2D tex_0;
            uniform sampler2D tex_1;
            uniform sampler2D tex_2;
            uniform sampler2D tex_3;
            
            uniform vec4 bounds;
            
            varying vec2 frag_uv;
            
            void main() {
                
                vec2 alteredPosition; 
                alteredPosition.x = bounds.x + frag_uv.x * bounds.z;
                alteredPosition.y = bounds.y + frag_uv.y * bounds.w;
                
                float dist = 0.0;
                vec3 color;
                vec4 texture_weights;
                
                for (int i = 0; i < METABALL_C; i++) {
                    float distance = dot(metaballs[i].xy-alteredPosition.xy, metaballs[i].xy-alteredPosition.xy);
                    float blobbyness = -0.5;
                    float val = 1.0*exp(blobbyness*distance/(metaballs[i].z*metaballs[i].z)-blobbyness);
                
                    dist += val;
                    color += val*metaball_colors[i];
                    texture_weights += val*metaball_texture_weights[i];
                }
                
                color /= dist;
                texture_weights /= dist;
                
                // texture UV's, scaled to avoid texture stretching
                float ratio =  bounds.z/bounds.w;
                vec2 uv = frag_uv; 
                if (ratio < 1.0) {
                    uv.x *= ratio;
                }
                if (ratio > 1.0) {
                    uv.y /= ratio;
                }
                
                vec4 texture_colors;
                texture_colors += texture2D(tex_0, uv)*texture_weights.r;
                texture_colors += texture2D(tex_1, uv)*texture_weights.g;
                texture_colors += texture2D(tex_2, uv)*texture_weights.b;
                texture_colors += texture2D(tex_3, uv)*texture_weights.a;
                
                gl_FragColor = vec4(color,1.0) * texture_colors * (dist-0.25); // 3.0; // 
                
                /*
                if (frag_uv_2.x <= 1.0 && frag_uv_2.y > 1.0) {
                    gl_FragColor = vec4(dist, dist, dist, 1.0);
                }
                if (frag_uv_2.x > 1.0 && frag_uv_2.y > 1.0) {
                    gl_FragColor = vec4(color,1.0);
                }
                if (frag_uv_2.x <= 1.0 && frag_uv_2.y < 1.0) {
                    gl_FragColor = texture_colors;
                }
                if (frag_uv_2.x > 1.0 && frag_uv_2.y <= 1.0) {
                    gl_FragColor = vec4(color,1.0) * texture_colors * dist;
                }
                */
                
                //gl_FragColor = vec4((dist-0.5) / 2.0, (dist-0.5) / 2.0, (dist-0.75) / 2.0, 1.0);
                //gl_FragColor = vec4(frag_uv, 0.0, 1.0);
                //gl_FragColor.r = alteredPosition.x / bounds.z;
                //gl_FragColor.g = alteredPosition.y / bounds.w;
                //gl_FragColor.b = 0.0;
                
                //gl_FragColor.r = vertexPosition.x;
                //gl_FragColor.g = vertexPosition.y;
                //gl_FragColor.b = 0.0;
                
                //gl_FragColor = vec4(1.0,1.0,1.0,1.0);
			}
		</script>
	</head>
	<body onload="onLoad()">
		<div id="myCanvasContainer"></div>
	</body>
</html>