<!DOCTYPE>
<html>
	<head>
		<title>Prototype</title>
		<script type="text/javascript" src="three.r87.js"></script>
        <script type="text/javascript" src="bundle.js"></script>
        <script type="text/javascript" src="http://rawgit.com/mrdoob/stats.js/master/build/stats.min.js"></script>
		<script type="text/javascript">
		
			var renderer, scene, camera;
			var lookAt = new THREE.Vector3(0.0, 0.0, 0.0);
			var viewerPosition = new THREE.Vector3(0.0, 0.0, 30.0);
            
            var skeleton;
            var metaballs;
            var polygon;
            
            var lines;
            var triangles;
            var skeletonhelper;
            
            var interval = 5;
            var smoothInterpolation = true;
            var wireframe = false;
            var paused = false;
            
            var clock = new THREE.Clock();
            
			var stats = new Stats();
			stats.showPanel( 1 ); // 0: fps, 1: ms, 2: mb, 3+: custom
			
			function millis() {

				return (new Date()).getTime();
			}
			
			function toRad(degree) {
			
				return Math.PI * 2 * degree / 360;
			}
		
			function onLoad() { 
				var canvasContainer = document.getElementById('myCanvasContainer');
                document.body.appendChild( stats.dom );
				var width = 800; 
				var height = 500;
				
				renderer = new THREE.WebGLRenderer(); 
				renderer.setSize(width, height);
				canvasContainer.appendChild(renderer.domElement);
				
				scene = new THREE.Scene();
                
				camera = new THREE.OrthographicCamera( width / - 2, width / 2, height / 2, height / - 2, 1, 1000 );
				camera.position.set(viewerPosition.x, viewerPosition.y, viewerPosition.z);
				camera.up = new THREE.Vector3(0, 1, 0);
				camera.lookAt(lookAt);
				
				vertexShader = document.getElementById('vertexShader').textContent;
				fragmentShader = document.getElementById('fragmentShader').textContent;
                
                
                
                skeleton = generateSkeleton();
                metaballs = [];
                generateMetaballs(metaballs, skeleton.bones[0]);
                console.log(metaballs);
                
                // DEBUG DISPLAY
                fragmentShader = fragmentShader.replace("METABALL_COUNT", metaballs.length).replace("METABALL_COUNT", metaballs.length);
                console.log(fragmentShader);
                
                var geometry = new THREE.PlaneBufferGeometry( 500, 500 );
                var material = new THREE.ShaderMaterial({
					uniforms: {
                        metaballs: new THREE.Uniform(metaballs)
                    },
					vertexShader: vertexShader,
					fragmentShader: fragmentShader,
                    side: THREE.DoubleSide
				});
                var plane = new THREE.Mesh( geometry, material );
                //scene.add( plane );
                
                
                //--------------------------
                    
                    polygon = generatePolygon(metaballs);

                    lines = new THREE.Line( new THREE.Geometry, new THREE.LineBasicMaterial({color: 0xff00ff00}) );
                    lines.geometry.vertices = polygon;
                    lines.geometry.verticesNeedUpdate = true;
                    lines.position.z += 1;
                    
                    //scene.add(lines);
                    
                    triangles = generateMesh(polygon, metaballs, skeleton);
                    skeletonhelper = new THREE.SkeletonHelper( triangles );
                    
                    scene.add(triangles);
                    scene.add(skeletonhelper);
                
                    dataContainer.children[1].innerHTML = polygon.length.toString();
                    dataContainer.children[4].innerHTML = triangles.geometry.faces.length.toString();
                    
                //--------------------------
				draw();
				
                
				window.addEventListener('keydown', function(event) {
					if (event.keyCode == 38) { //Up
						smoothInterpolation = true;
                        interpolationStatusContainer.children[1].innerHTML = smoothInterpolation.toString();
					}
					if (event.keyCode == 40) { //Down
						smoothInterpolation = false;
                        interpolationStatusContainer.children[1].innerHTML = smoothInterpolation.toString();
					}
					if (event.keyCode == 37) { //Right
						interval--;
                        if (interval < 1)
                            interval = 1;
                        gridStatusContainer.children[1].innerHTML = interval.toString();
					}
					if (event.keyCode == 39) { //Left
                        interval++;
                        gridStatusContainer.children[1].innerHTML = interval.toString();
					}
					if (event.keyCode == 87) { //W
                        wireframe = !wireframe;
                        triangles.material.wireframe = wireframe;
                        wireframeStatusContainer.children[1].innerHTML = wireframe.toString();
					}
                    if (event.keyCode == 32) { //Space
                        console.log(lines.geometry.vertices)
                        paused = !paused;
					}
				}, false);
                
			}
			
			function draw() {
				requestAnimationFrame(draw);
                
                stats.begin();
				
                var dt = clock.getDelta();
                
                if (!paused) {
                    
                    //skeleton.bones[1].rotation.z += dt;
                    //skeleton.bones[1].rotation.z += dt;
                    
                    for (var i = 0; i < skeleton.bones.length; i++) {
                        skeleton.bones[i].rotation.z = Math.sin(clock.getElapsedTime()*(i+1));
                    }
                    
                    /*
                    polygon = generatePolygon(metaballs);
                    
                    scene.remove(lines);

                    lines = new THREE.Line( new THREE.Geometry, new THREE.LineBasicMaterial({color: 0xff00ff00}) );
                    lines.geometry.vertices = polygon;
                    lines.geometry.verticesNeedUpdate = true;
                    lines.position.z += 1;
                    
                    scene.add(lines);
                    


                    scene.remove(triangles);
                    scene.remove(skeletonhelper);
                    
                    triangles = generateMesh(polygon, metaballs, skeleton);
                    skeletonhelper = new THREE.SkeletonHelper( triangles );
                    
                    scene.add(triangles);
                    scene.add(skeletonhelper);
                    
                    dataContainer.children[1].innerHTML = polygon.length.toString();
                    dataContainer.children[4].innerHTML = triangles.geometry.faces.length.toString();
                    */
                    
                }
                
				renderer.render(scene, camera);
                
                stats.end();
			}
            
            function generateSkeleton() {
                /*
                bone = new THREE.Bone();
                    bone.thickness = 20;
                var b2 = new THREE.Bone();
                    b2.thickness = 20;
                    bone.add(b2);
                    b2.position.y = 100;
                
                var b3 = new THREE.Bone();
                    b3.thickness = 20;
                    b2.add(b3);
                    b3.position.x = 150;
                    b3.position.y = 100;
                
                
                var b31 = new THREE.Bone();
                    b31.thickness = 30;
                    b3.add(b31);
                    b31.position.y = -100;
                
                var b311 = new THREE.Bone();
                    b311.thickness = 5;
                    b31.add(b311);
                    b311.position.y = -10;
                    b311.position.x = -20;
                
                var b312 = new THREE.Bone();
                    b312.thickness = 5;
                    b31.add(b312);
                    b312.position.y = -10;
                    b312.position.x = 20;
                
                var b313 = new THREE.Bone();
                    b313.thickness = 5;
                    b31.add(b313);
                    b313.position.y = -20;
                
                
                var b4 = new THREE.Bone();
                    b4.thickness = 20;
                    b2.add(b4);
                    b4.position.x = -150;
                    b4.position.y = 100;
                
                
                var b41 = new THREE.Bone();
                    b41.thickness = 30;
                    b4.add(b41);
                    b41.position.y = -100;
                
                var skeleton = new THREE.Skeleton([bone, b2, b3, b31, b311, b312, b313, b4, b41]);
                return skeleton;
                */
                /*
                bone = new THREE.Bone();
                    bone.thickness = 20;
                
                var b2 = new THREE.Bone();
                    b2.thickness = 20;
                    bone.add(b2);
                    b2.position.y = 50;
                
                var b3 = new THREE.Bone();
                    b3.thickness = 10;
                    b2.add(b3);
                    b3.position.x = 90;
                
                var b4 = new THREE.Bone();
                    b4.thickness = 10;
                    b2.add(b4);
                    b4.position.x = -90;
                
                var b5 = new THREE.Bone();
                    b5.thickness = 10;
                    bone.add(b5);
                    b5.position.x = -50;
                    b5.position.y = -50;
                
                var b6 = new THREE.Bone();
                    b6.thickness = 10;
                    bone.add(b6);
                    b6.position.x = 50;
                    b6.position.y = -50;
                
                var b7 = new THREE.Bone();
                    b7.thickness = 10;
                    b2.add(b7);
                    b7.position.y = 50;
                
                var b8 = new THREE.Bone();
                    b8.thickness = 20;
                    b7.add(b8);
                
                var skeleton = new THREE.Skeleton([bone, b2, b3, b4, b5, b6, b7, b8]);
                return skeleton;
                */
                
                bone = new THREE.Bone();
                    bone.thickness = 20;
                
                var b2 = new THREE.Bone();
                    b2.thickness = 20;
                    bone.add(b2);
                    b2.position.x = 40;
                
                var b3 = new THREE.Bone();
                    b3.thickness = 20;
                    b2.add(b3);
                    b3.position.x = 40;
                
                var b4 = new THREE.Bone();
                    b4.thickness = 20;
                    b3.add(b4);
                    b4.position.x = 40;
                
                var b5 = new THREE.Bone();
                    b5.thickness = 20;
                    b4.add(b5);
                    b5.position.x = 40;
                
                var skeleton = new THREE.Skeleton([bone, b2, b3, b4, b5]);
                return skeleton;
                
            }
            
            function generateMetaballs(metaballs, bone, parent) {
                if (parent !== undefined) {
                    var subballs = 10;
                    
                    var boneLocation = bone.getWorldPosition();
                    boneLocation.z = bone.thickness / Math.sqrt(subballs);
                    var parentLocation = parent.getWorldPosition();
                    
                    parentLocation.z = bone.thickness / Math.sqrt(subballs);
                    
                    for (var i = 1; i <= subballs; i++) {
                        var alpha = i/subballs;
                        var ball = boneLocation.clone().lerp(parentLocation, alpha);
                        ball.boneID = skeleton.bones.indexOf(parent);
                        metaballs.push(ball);
                    }
                    
                    //metaballs.push(boneLocation);
                }
                
                bone.children.forEach(function(child) {
                    generateMetaballs(metaballs, child, bone);
                });
            }
            
            const UP = 0;
            const DOWN = 1;
            const LEFT = 2;
            const RIGHT = 3;
            
            function generatePolygon(metaballs) {
                var start = metaballs[0];
                for (var i = 1; i < metaballs.length; i++) {
                    if (metaballs[i].y > start.y) {
                        start = metaballs[i];
                    }
                }
                start = start.clone();
                
                start.z = 0;
                /*
                start.divideScalar(interval);
                start.ceil();
                start.multiplyScalar(interval);
                */
                while (calculateValueAt(start, metaballs) >= 1.0) {
                    start.add(new THREE.Vector3(0.0, interval));
                }
                
                var topLeft, topRight, bottomLeft, bottomRight;
                /*
                var topLeft = start.clone();
                var topRight = topLeft.clone().add(new THREE.Vector3(interval, 0));
                var bottomLeft = topLeft.clone().add(new THREE.Vector3(0.0, -interval));
                var bottomRight = topLeft.clone().add(new THREE.Vector3(interval, -interval));
                */
                topRight = addValueTo(start.clone(), metaballs);
                bottomRight = addValueTo(start.clone().add(new THREE.Vector3(0.0, -interval)), metaballs);
                
                var prev = RIGHT;
                
                var vertices = [];

                passedStart = false;
                while (true) {
                    if (prev == RIGHT && topRight.equals(start)) {
                        if (passedStart) {
                            break;
                        }
                        passedStart = true;
                    }
                    
                    if (prev == UP) {
                        bottomLeft = topLeft;
                        bottomRight = topRight;
                        topLeft = addValueTo(bottomLeft.clone().add(new THREE.Vector3(0.0, interval)), metaballs);
                        topRight = addValueTo(bottomRight.clone().add(new THREE.Vector3(0.0, interval)), metaballs);
                        
                        var tl = topLeft.value >= 1.0;
                        var tr = topRight.value >= 1.0;
                        var bl = bottomLeft.value >= 1.0;
                        var br = bottomRight.value >= 1.0;
                        
                        if (tl && tr) {
                            prev = LEFT;
                            vertices.push(interpolateLocation(topLeft, bottomLeft));
                            continue;
                        }
                        if (!tl && tr) {
                            prev = UP;
                            vertices.push(nextVertex(prev, topLeft, topRight, bottomLeft, bottomRight));
                            continue;
                        }
                        if (!tl && !tr) {
                            prev = RIGHT;
                            vertices.push(nextVertex(prev, topLeft, topRight, bottomLeft, bottomRight));
                            continue;
                        }
                        if (tl && !tr) {
                            var middle = addValueTo(topLeft.clone().add(bottomRight).divideScalar(2.0), metaballs);
                            if (middle.value >= 1.0) {
                                prev = LEFT;
                                vertices.push(nextVertex(prev, topLeft, topRight, bottomLeft, bottomRight));
                            } else {
                                prev = RIGHT;
                                vertices.push(nextVertex(prev, topLeft, topRight, bottomLeft, bottomRight));
                            }
                            continue;
                        }
                    }
                    
                    if (prev == DOWN) {
                        topLeft = bottomLeft;
                        topRight = bottomRight;
                        bottomLeft = addValueTo(topLeft.clone().add(new THREE.Vector3(0.0, -interval)), metaballs);
                        bottomRight = addValueTo(topLeft.clone().add(new THREE.Vector3(interval, -interval)), metaballs);
                        
                        var tl = topLeft.value >= 1.0;
                        var tr = topRight.value >= 1.0;
                        var bl = bottomLeft.value >= 1.0;
                        var br = bottomRight.value >= 1.0;
                        
                        if (bl && br) {
                            prev = RIGHT;
                            vertices.push(nextVertex(prev, topLeft, topRight, bottomLeft, bottomRight));
                            continue;
                        }
                        if (!bl && !br) {
                            prev = LEFT;
                            vertices.push(nextVertex(prev, topLeft, topRight, bottomLeft, bottomRight));
                            continue;
                        }
                        if (bl && !br) {
                            prev = DOWN;
                            vertices.push(nextVertex(prev, topLeft, topRight, bottomLeft, bottomRight));
                            continue;
                        }
                        if (!bl && br) {
                            var middle = addValueTo(topLeft.clone().add(bottomRight).divideScalar(2.0), metaballs);
                            if (middle.value >= 1.0) {
                                prev = RIGHT;
                                vertices.push(nextVertex(prev, topLeft, topRight, bottomLeft, bottomRight));
                            } else {
                                prev = LEFT;
                                vertices.push(nextVertex(prev, topLeft, topRight, bottomLeft, bottomRight));
                            }
                            continue;
                        }
                    }
                    
                    if (prev == LEFT) {
                        topRight = topLeft;
                        bottomRight = bottomLeft;
                        topLeft = addValueTo(topRight.clone().add(new THREE.Vector3(-interval, 0.0)), metaballs);
                        bottomLeft = addValueTo(bottomRight.clone().add(new THREE.Vector3(-interval, 0.0)), metaballs);
                        
                        var tl = topLeft.value >= 1.0;
                        var tr = topRight.value >= 1.0;
                        var bl = bottomLeft.value >= 1.0;
                        var br = bottomRight.value >= 1.0;
                        
                        if (tl && bl) {
                            prev = DOWN;
                            vertices.push(nextVertex(prev, topLeft, topRight, bottomLeft, bottomRight));
                            continue;
                        }
                        if (!tl && !bl) {
                            prev = UP;
                            vertices.push(nextVertex(prev, topLeft, topRight, bottomLeft, bottomRight));
                            continue;
                        }
                        if (tl && !bl) {
                            prev = LEFT;
                            vertices.push(nextVertex(prev, topLeft, topRight, bottomLeft, bottomRight));
                            continue;
                        }
                        if (!tl && bl) {
                            var middle = addValueTo(topLeft.clone().add(bottomRight).divideScalar(2.0), metaballs);
                            if (middle.value >= 1.0) {
                                prev = DOWN;
                                vertices.push(nextVertex(prev, topLeft, topRight, bottomLeft, bottomRight));
                            } else {
                                prev = UP;
                                vertices.push(nextVertex(prev, topLeft, topRight, bottomLeft, bottomRight));
                            }
                            continue;
                        }
                    }
                    
                    if (prev == RIGHT) {
                        topLeft = topRight;
                        bottomLeft = bottomRight;
                        topRight = addValueTo(topLeft.clone().add(new THREE.Vector3(interval, 0.0)), metaballs);
                        bottomRight = addValueTo(bottomLeft.clone().add(new THREE.Vector3(interval, 0.0)), metaballs);
                        
                        var tl = topLeft.value >= 1.0;
                        var tr = topRight.value >= 1.0;
                        var bl = bottomLeft.value >= 1.0;
                        var br = bottomRight.value >= 1.0;
                        
                        if (tr && br) {
                            prev = UP;
                            vertices.push(nextVertex(prev, topLeft, topRight, bottomLeft, bottomRight));
                            continue;
                        }
                        if (!tr && !br) {
                            prev = DOWN;
                            vertices.push(nextVertex(prev, topLeft, topRight, bottomLeft, bottomRight));
                            continue;
                        }
                        if (!tr && br) {
                            prev = RIGHT;
                            vertices.push(nextVertex(prev, topLeft, topRight, bottomLeft, bottomRight));
                            continue;
                        }
                        if (tr && !br) {
                            var middle = addValueTo(topLeft.clone().add(bottomRight).divideScalar(2.0), metaballs);
                            if (middle.value >= 1.0) {
                                prev = UP;
                                vertices.push(nextVertex(prev, topLeft, topRight, bottomLeft, bottomRight));
                            } else {
                                prev = DOWN;
                                vertices.push(nextVertex(prev, topLeft, topRight, bottomLeft, bottomRight));
                            }
                            continue;
                        }
                    }
                }
                
                return vertices;
            }
            
            function generateMesh(polygon, metaballs, skeleton) {
                var triangles = new THREE.SkinnedMesh( new THREE.Geometry, new THREE.MeshBasicMaterial({color: 0xffffffff, wireframe: wireframe, skinning:true}) );
                triangles.geometry.vertices = polygon.slice(0);

                // vertices
                var points = [];

                for (var i = 0; i < polygon.length; i++) {
                    points.push([polygon[i].x, polygon[i].y]);
                }
                
                /*
                for (var i = 0; i < Math.min(metaballs.length, 40); i++) {
                    if (i == 29 || i == 39)
                        continue;
                    metaball_loc = metaballs[i].clone();
                    metaball_loc.z = 0;
                    triangles.geometry.vertices.push(metaball_loc);
                    points.push([metaball_loc.x, metaball_loc.y])
                }
                */
                
                var lowestX = polygon[0].x, lowestY = polygon[0].y, highestX = polygon[0].x, highestY = polygon[0].y;
                for (var i = 0; i < polygon.length; i++) {
                    lowestX = Math.min(lowestX, polygon[i].x)
                    lowestY = Math.min(lowestY, polygon[i].y)
                    highestX = Math.max(highestX, polygon[i].x)
                    highestY = Math.max(highestY, polygon[i].y)
                }
                
                var offset = highestY-lowestY;
                for (var x = lowestX+0.01; x < highestX+offset; x+=20.1711) {
                    for (var y = lowestY+0.01; y < highestY; y+=20.1711) {
                        var skew = (y-lowestY)/2;
                        triangles.geometry.vertices.push(new THREE.Vector3(x-skew, y, 0));
                        points.push([x-skew, y])
                    }
                }
                
                var edges = [];
                for (var i = 0; i < polygon.length; i++) {
                    var j = (i + 1) % polygon.length;
                    edges.push([i, j]);
                }
                
                // faces
                var faces = cdt2d(points, edges, {exterior: false});
                
                for (var i = 0; i < faces.length; i++) {
                    triangles.geometry.faces.push( new THREE.Face3(faces[i][0],faces[i][1],faces[i][2]) );
                }
                
                triangles.geometry.computeVertexNormals();
                
                // skinning
                triangles.add(skeleton.bones[0]);
                for (var i = 0; i < triangles.geometry.vertices.length; i++) {
                    var data = calculateSkinningData(triangles.geometry.vertices[i], metaballs, skeleton);
                    //console.log(data);
                    triangles.geometry.skinIndices.push( data[0] );
                    triangles.geometry.skinWeights.push( data[1] );
                }
                triangles.bind( skeleton );
                
                return triangles;
            }
            
            function nextVertex(dir, topLeft, topRight, bottomLeft, bottomRight) {
                if (dir == UP) {
                    return interpolateLocation(topLeft, topRight);
                }
                if (dir == DOWN) {
                    return interpolateLocation(bottomLeft, bottomRight);
                }
                if (dir == LEFT) {
                    return interpolateLocation(topLeft, bottomLeft);
                }
                if (dir == RIGHT) {
                    return interpolateLocation(topRight, bottomRight);
                }
            }
            
            function addValueTo(vec, metaballs) {
                vec.value = calculateValueAt(vec, metaballs);
                return vec;
            }
            
            function calculateValueAt(c, metaballs) {
                var x = c.x;
                var y = c.y;
                var val = 0.0;
                for (var i = 0; i < metaballs.length; i++) {
                    metaball = metaballs[i];
                    addedVal = Math.pow(metaball.z, 2.0)/(Math.pow(metaball.x-x, 2.0)+Math.pow(metaball.y-y, 2.0));
                    if (!isFinite(addedVal))
                        addedVal = 10000.0;
                    val += addedVal;
                }
                return val;
            }
            
            function calculateSkinningData(v, metaballs, skeleton) {
                var x = v.x;
                var y = v.y;
                
                boneValues = []
                for (var i = 0; i < skeleton.bones.length; i++) [boneValues.push(0)]
                
                for (var i = 0; i < metaballs.length; i++) {
                    metaball = metaballs[i];
                    distance = (Math.pow(metaball.x-x, 2.0)+Math.pow(metaball.y-y, 2.0));
                    addedVal = Math.pow(Math.pow(metaball.z, 2.0)/distance, 2.0);
                    if (!isFinite(addedVal))
                        addedVal = 10000.0;
                    
                    boneValues[metaball.boneID] += addedVal;
                }
                //console.log(boneValues)
                
                var sortedBoneValues = boneValues.slice()
                sortedBoneValues.sort(function(a, b){return b - a});
                
                boneIndices = new THREE.Vector4( 
                        boneValues.indexOf(sortedBoneValues[0]), 
                        boneValues.indexOf(sortedBoneValues[1]), 
                        boneValues.indexOf(sortedBoneValues[2]), 
                        boneValues.indexOf(sortedBoneValues[3])
                    );
                
                boneWeights = new THREE.Vector4( 
                        sortedBoneValues[0],
                        sortedBoneValues[1], 
                        sortedBoneValues[2], 
                        sortedBoneValues[3]
                    );
                
                boneWeights.divideScalar(boneWeights.lengthManhattan());
                
                return [boneIndices, boneWeights];
                
                //return [new THREE.Vector4( 0, 1, 0, 0), new THREE.Vector4( 0.5, 0.5, 0,  0)]
                
            }
            
            function interpolateLocation(loc1, loc2) {
                var val1 = loc1.value;
                var val2 = loc2.value;
                var a = (1-val2)/(val1-val2);
                if (!smoothInterpolation)
                    a = 0.5;
                //return loc1.clone().multiplyScalar(a).add( loc2.clone().multiplyScalar(1-a) );
                if (isNaN(loc1.clone().lerp(loc2, 1-a).x)) {
                    console.log(loc1, loc2);
                }
                
                return (loc1.clone().lerp(loc2, 1-a));
            }
			
		</script>

		<script id="vertexShader" type="x-shader/x-vertex">
			varying vec3 vertexPosition;
			void main() {
				vertexPosition = position;
				gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);
			}
		</script>
		<script id="fragmentShader" type="x-shader/x-fragment">
            uniform vec3 metaballs[METABALL_COUNT];
            varying vec3 vertexPosition;
            void main() {
                
                float dist = 0.0;
                for (int i = 0; i < METABALL_COUNT; i++) {
                    dist += pow(metaballs[i].z, 2.0) / dot(metaballs[i].xy-vertexPosition.xy, metaballs[i].xy-vertexPosition.xy);
                }
                if (dist < 1.0) {
                    gl_FragColor = vec4(dist, 0.0, 0.0, 1.0);
                } else {
                    gl_FragColor = vec4(0.0, 0.0, dist-1.0, 1.0);
                }
                /*
                float dist = 0.0;
                for (int i = 0; i < METABALL_COUNT; i++) {
                    dist = pow(metaballs[i].z, 2.0) / dot(metaballs[i].xy-vertexPosition.xy, metaballs[i].xy-vertexPosition.xy) > 1.0 ? 1.0 : dist;
                }
                if (dist < 1.0) {
                    gl_FragColor = vec4(dist, 0.0, 0.0, 1.0);
                } else {
                    gl_FragColor = vec4(0.0, 0.0, dist, 1.0);
                }*/
			}
		</script>
	</head>
	<body onload="onLoad()">
		<div id="myCanvasContainer"></div>
        <div id="dataContainer">
			<span>Vertex count:</span>
			<span>0</span>
            <div></div>
            <span>Triangle count:</span>
			<span>0</span>
		</div>
		<div id="gridStatusContainer">
			<span>(left/right arrows) Grid interval:</span>
			<span>10</span>
		</div>
		<div id="interpolationStatusContainer">
			<span>(up/down arrows) Smooth interpolation:</span>
			<span>true</span>
		</div>
		<div id="wireframeStatusContainer">
			<span>(w) Wireframe:</span>
			<span>false</span>
		</div>
		<div>
			<span>(Space) Pause</span>
		</div>
	</body>
</html>